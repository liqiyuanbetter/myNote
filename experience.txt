2017.09.06
关于字节流和字符流
Object
	----InputStream，读图像之类的字节流
		----FileInputStream
		1. 它的构造函数参数是文件名(String)或文件(File), 很单纯简单
		----DataInputStream(数据输入流)
		1. 构造函数的参数是一个字节流(InputStream)
		2. 数据输入流允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型，用于读取基本数据类型，因此它的
	方法都是readInt, readLong这种read+基本数据类型的样子

	----Reader，读取数字符号等字符流
		----BufferedReader
		1. 从字节输入流中高效的读取文本, 因此其构造函数参数都是字符输入流(Reader)
		2. Reader的直接子类中, 只有BufferedReader有读取整行的readLine方法
		----InputStreamReader
		1. 字节流通向字符流的桥梁：它使用指定的 charset 读取字节并将其解码为字符
		2. 因此它的构造函数都是含字节输入流的(InputStream), 毕竟是字符流和字节流之间的桥梁
			----FileReader
			1. 它的构造函数参数是文件名(String)或文件(File), 很单纯简单
	因此可能出现这样一种非常长的声明:
		Reader reader = new BufferedReader(new InputStreamReader(new FileInputStream(new File(fileName))))

2017.09.07
1. 关于maven
	关于引用jar包的问题
			1. 在新建普通的web项目时，项目自动在build path中添加了apachet tomcat相关jar包，因此可以直接使用servlet
		但是maven项目中默认jar包只有系统jar包，此外外所有jar包都依赖于pom文件中的引入，解决方法有两个:
				1. 一个是右键项目的build path中添加Server Runtime
				2. 一个是在pom中引入依赖javax.servlet-api
			2. 另外重要的是, 在引入servlet依赖时, scrope范围一定要指定为provided，它表示在项目的编译和测试阶段该jar
		包生效。而打成war包的时候不会加入。因为比如项目运行在tomcat容器中时, tomcat会提供jar包, 再打包进去就会发生冲突；
			3. 此外, 依赖默认的范围是compile, 它表示在项目的整个测试, 编译, 打包阶段都生效

2. 关于jstl标签
	关于这里引用jstl包的问题, 如果引用的是javax.servlet.jsp.jstl而不是javax.servlet就会出错
	但是在maven仓库中显示已经将该artifact 移入了javax.servlet.jsp.jstl

3. 软件安装不安全官方说法
		you are installing software that contains unsigned content.The authenticity or validity of this software
	cannot be established.Do you want to continue with this installation?

4. Velocity 学习地址
	http://blog.csdn.net/qq_25237663/article/details/52262532
	http://ifeve.com/apache-velocity-dev/
	http://www.360doc.com/content/13/0401/13/10825198_275274565.shtml
	https://www.ibm.com/developerworks/cn/java/j-lo-velocity1/

2017.09.08
1. Velocity配置文件
	http://blog.csdn.net/glarystar/article/details/6636574
	http://blog.csdn.net/Lancelot_Lewis/article/details/51222596

2. 注意velocity的配置文件编写后要在web.xml文件中设置，设置位置在servlet的initparam里面, 比如:
	<!-- 定义自己的配置文件 -->
	<init-param>
		<param-name>org.apache.velocity.properties</param-name>
		<param-value>mvelocity.properties</param-value>
	</init-param>

2017.09.11
1. 学习spring不错地址:
	http://snowolf.iteye.com/blog/1628861
	http://blog.csdn.net/qq_31138523/article/details/60584333

2017.09.18
1. 将项目部署到服务器上的步骤
	1. 在eclipse中将项目打包, 方法为在maven中执行命令clean package;
	2. 项目部署到服务器上后可以不用修改服务器上的应用的数据库地址，因为数据库在服务器上，应用配置的数据
地址是127.0.0.1，运行在服务器的应用使用这个地址时就是连接的服务器上的数据库;
	3. 对应用的访问也类似，本地访问时通过localhost，服务器上结合ngix只需要将地址换为服务器ip。例如，在服务器本地访问
时也是通过localhost:port/proName，现在通过ngix映射访问--服务器ip(默认端口80)/proName时直接映射到localhost:port/proName，
这样来实现在服务器上运行在tomcat中的项目。不直接使用服务器地址:port/proName的原因是服务器只对外暴露80端口，而外部通过
请求地址的不同映射到服务器本地的不同端口上，因此访问服务器上的应用时可以不加端口号，而是通过ngix自动映射了;
	4. 将war包放入tomcat的webapp即可，tomcat会自动解释翻译项目;

2. 在tomcat的bin/catalina.bat中通过setTitle可以指定服务启动的名称，默认为tomcat。这样可以区分运行在不同版本tomcat上的应用。
3. 将tomcat的项目配置在其他文件夹的方法
4. github教程
	1. http://jingyan.baidu.com/article/f7ff0bfc7181492e27bb1360.html

2017.09.19
js变量声明提升
	http://www.cnblogs.com/silentjesse/p/4024536.html

2017.09.20
1. windows server上配置tomcat服务器，需要在防火墙--高级设置--入站规则--新建入站规则，选择端口并指定特定本地端口为8080
方可通过ip:8080访问tomcat的index
	1. 局域网中没有添加入站规则也能访问？
	2. ajax post通过？传参数
2. windows server 
	1. http://blog.163.com/smile_big/blog/static/35710579201432510300378/
	2. http://www.xitonghe.com/jiaocheng/diannao-2534.html
	3. http://www.cnblogs.com/XieSir/articles/3420154.html
	4. http://jingyan.baidu.com/article/90895e0ffb5c1764ec6b0bbb.html

3. maven打包部署
	1. http://www.cnblogs.com/tangwan/p/4662107.html
	2. http://blog.csdn.net/u010022051/article/details/50585752
	3. http://blog.csdn.net/a468903507/article/details/45392083

4. mysql
	1. http://blog.csdn.net/q98842674/article/details/12094777/
	2. http://blog.csdn.net/wengengeng/article/details/52013650
	3. http://jingyan.baidu.com/article/f3ad7d0ffc061a09c3345bf0.html
2017.09.21

<build>
		<finalName>MyDemo</finalName>
		<plugins>
			<plugin>
				<groupId>org.apache.tomcat.maven</groupId>
				<artifactId>tomcat7-maven-plugin</artifactId>
				<version>2.2</version>
				<configuration>
					<!-- <port>8088</port>
					<url>http://localhost:8080/Demo</url>
					<server>local_tomcat</server>
					<ignorePackaging>true</ignorePackaging>
					<contextReloadable>true</contextReloadable> -->
					<!-- server、username、password对应maven的setting下的配置 -->
					<!-- <server>
						<id>tomcat</id>
						<username>lqy</username>
						<password>lqy</password>
					</server> -->
					<!-- <path>/${project.build.finalName}</path> -->
					<!-- war文件路径缺省情况下指向target -->
					<!--<warFile>${basedir}/target/${project.build.finalName}.war</warFile> -->
				</configuration>
			</plugin>

			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<version>3.6.1</version>
				<configuration>
					<source>1.8</source>
					<target>1.8</target>
				</configuration>
			</plugin>

		</plugins>
	</build>
1. 安装mysql
	1. 5.7的高版本
		1. 解压mysql后在path中添加mysql的bin目录的路径，可采取添加变量%MYSQL_HOME%的形式;

		2. 在cmd命令中执行mysqld --initialize命令会在mysql根目录下生成data文件夹，保存数据库等数据。如果没有在
	path中配置bin路径，则需要在bin目录中执行mysqld命令;初始化成功后，会在data目录下生成一些文件，其中，xxx.error.log文件
	里说明了root账户的临时密码。其内容为：
		2017-09-21T01:23:31.812068Z 1 [Note] A temporary password is generated for root@localhost: Yi%#y;dtA6pp
	后面的一串字符即初始的密码;

		3. 执行安装服务命令mysqld install serverName --defaults-file="...my.ini", 其中serverName是自己指定的计算机上
	该mysql服务的名称，同时可以指定安装的配置文件。

		4. 在使用cmd登录mysql时，需要输入 mysql -u root -p, 这里不需要输入密码，回车后再输入密码即可，因为输入密码是*
	号表示的，直接在一行里面输入会暴露密码，因此命令提示enter password后再输入密码，这是输入2中初始密码即可。

		5. 进入mysql后想操纵数据库会提示操作功能不完全需要重置密码，重置密码命令为
			1. alter user 'root'@'localhost' identified by '123';
			2. set password for 'root'@'localhost'=password('123'), 此处password是一个加密的函数;
		第一次或是之后重置命令都是用的这个，因为这是在进入数据库后执行的，所以不需要输入原来的密码。

		6. 注意事项
			1. 5.7之后数据库mysql的user表中不再有password这个字段，而是修改成了authentication_string字段，该字段
		内容为加密后的密码。所以也可以通过修改user表中的user字段来修改登录名，比如将root改为lqy
			use mysql;
			update user set user="lqy" where user="root";
		这张表中的其他字段说明该用户对数据库操作的权限。

			2. 在my.ini配置文件中的[mysqld]下面加上skip-grant-tables可跳过所有密码验证，此时发现在navicat中
		使用任何账号密码登录都能成功;
			
			3. 如果忘记了密码想要重新修改，步骤如下：
				1. 停止mysql服务，将该服务对应的配置文件加上skip-grant-tables，然后重启服务进入mysql;
				2. 通过上面的方式修改密码，发现提示在skip-grant-tables无法修改，这是再键入flush privileges;
			命令，然后再次修改密码；
				3. 修改配置文件不跳过密码，然后再重启服务，通过mysql -u user -p然后输入密码登录

2. spring boot
	1. http://www.cnblogs.com/larryzeal/p/5799195.html
	2. http://www.cnblogs.com/ityouknow/p/5662753.html
	3. http://www.mldnjava.cn/book/springboot.htm

2017.09.22
1. 关于maven
	1. maven中的parent标签
		建立一个maven项目，然后再在其中新建maven module项目，则新建的子项目的pom文件中自动会生成
		<parent>
			<groupId>com.oldbutcher.maventest</groupId>
			<artifactId>Aggregator</artifactId>
			<version>0.0.1-SNAPSHOT</version>
		</parent>
		父项目中会自动生成modules标签<module>子项目名</module>
		子项目相当于集成了父项目的依赖。新建的子项目除了上面的内容和基本的pom.xml的声明外只会有一个
		<artifactId>a-persist</artifactId>
		如果新建子项目时额外指定了group-id则还会生成如<groupId>com.oldbutcher.maventest.asd</groupId>

	2. 引入parent有什么用呢？
		父项目中的所有依赖子项目会默认全部继承，也就是不需要再在子项目中添加dependency标签。但有时我们只希望引入父项
	目中的部分依赖，此时在父项目的dependency标签外再添加一层标签<dependencyManagement>。那么如果想在子项目中使用就
	需要再次使用dependency标签来引入依赖。但此时可以省略依赖中的<version>标签和<scope>标签，因为他们都由父类指定了。

	3. 另外如果父项目的pom文件中实际上可以写入多个dependencies，在dependencies中的依赖仍将全部被子项目继承。

	4. 关于import的使用
		1. import只能用在dependencyManagement下，写法如下
			<dependencyManagement>
				<dependencies>
					<dependency>
						<groupId>com.oldbutcher.maventest</groupId>
						<artifactId>Aggregator</artifactId>
						<type>pom</type>
						<scope>import</scope>
					</dependency>
				</dependencies>
			</dependencyManagement>
		2. 注意type为pom。这样该文件就引入了com.oldbutcher.maventest中的依赖，但仍需自己通过dependency标签引用。注意
	这里只能引用进父项目的dependencyManagement中的依赖，父项目的写在外面的依赖不能引入。

		3. 所以实际上子项目可以继承多个父项目，比如可以再写
			<dependency>
				<groupId>com.oldbutcher.maventest</groupId>
				<artifactId>another project artifactId</artifactId>
				<type>pom</type>
				<scope>import</scope>
			</dependency>

	5. 通过<properties>元素用户可以自定义一个或多个Maven属性，然后在POM的其他地方使用${属性名}的方式引用该属性，比如
		<properties>
			<spring.version>4.0.2.RELEASE</spring.version>
		</properties>
		然后在下面的依赖中可以这样写:
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-core</artifactId>
			<version>${spring.version}</version>
		</dependency>

2017.09.25
1. jquery中的on事件
	1. 不能使用原生js如var e = getElement..得到元素后给其添加on事件，也不能使用$("button")[0]来添加on事件;

	2. on事件中如果没有selector，那就是在该元素下面所有范围内添加了事件。例如如果是div就是整行添加。如果有selector，
该选择器必须是被添加事件元素的下面的子元素才行，否自无效。例如：
		<div id="test">
			test
			<div>sd</div>
		</div>
		$("#test").on("click", "div", function(e){} {
			console.log(this.innerHTML);
		});
	这样写之后，这个事件是添加在#test下面的div上而不是#test上，且这里的this指向的是它下面的div而不是#test, 打印sd;
	这里的this是<div>sd</div>，而如果写$(this)表示的是数组,但是该数组只有一个元素，且就是被点击的那个div。

2. jq通过选择器得到的元素跟document的到的元素本来就是两个不同的对象。例如：<button id="but">click</button>
	var but = document.getElementById("but"); 
	console.log($("#but")); // 输出结果为[button#but]
	console.log(but) // 输出结果为<button id="but">click</button>
	$("#test")里面封装了各种jquery自己定义的属性和原型

3. on用法讲解
	1. http://www.cnblogs.com/leejersey/p/3545372.html
	2. 前端特效： http://t.cn/RKj3egR

4. dom事件流，何为冒泡
	http://www.sohu.com/a/152795929_711545

5. ajax得到的数据写了dataType为json时，是否可以直接写data.属性名？可以，没写要通过JSON.parse(..)将其转换为js对象

6. trigger在每一个匹配的元素上直接触发某类事件;

2017.09.26
1. xss

2. 设置cookie为HttpOnly则无法通过js读取到该cookie信息，这样可以防止xss攻击
	1. jsession这个cookie之所以不能通过document.cookie访问是因为它是http only的，可以在谷歌中查看到它是不允许脚本访
的，且它是由服务器自动创建的；

	2. 我们可以在response中通过addCookie这个方法向浏览器中发送cookie，但是这样的cookie是可以通过脚本访问的。通过
addHeader方法可以设置cookie为httponly的，例如 
		response.addHeader("Set-Cookie", "cookie_name=cookie_value; Max-Age=2000; HttpOnly");

	3. 此外所有我们设置的cookie都能在response中看到, 例如
		Set-Cookie:coo_1=val_1
		Set-Cookie:coo_2=val_2; Max-Age=2000; HttpOnly

3. java中的反射

	1. 某个类没有默认不带参数构造函数能用newInstance吗?不能。

	2. 注解及反射：http://blog.csdn.net/zjf280441589/article/details/50444343

	3. 关于.class和getClass()方法
		1. 他们获得的都是类型类对象(注意得到的都是对象), 区别在于.class由类名直接调用, 而.getClass()由对象调用。
	而且obj.getClass == Object.class的结果为true;

		2. 注意，调用obj.getClass()获得obj的类型类对象, 但是obj.getClass().getClass()获得的是Class的类型类,
	换句话说obj.getClass().getName()打印的是obj全名, obj.getClass().getClass()打印的是java.lang.Class;

		3. 注意当某个方法的签名是 <T> .. funName(T t)时, 传入的参数必须是某个类的对象而不是某个类的类类型对象。
	传入后需要通过t.getClass()来获取该类的类对象，从而进行下一步操作如判断注解等。因此此时不可能通过类名.class传参数
	进去。因这里的t就跟一个最顶层的object类的对象一样，它并没有类类型对象的各种方法如获取注解，获取类名等，它里面只有
	Object类的几个基本方法。如果我们仍然使用t.getClass()这时得到的是Class类的类类型对象，也达不到我们想要的目的。

		4. 当方法的参数是(Class<?> clazz...)时，传入的参数只能是类类型对象, 如obj.getClass()或Obj.class, 而不能
	传入某个类的对象。此时传入的参数已经是某个类的类类型对象了，因此直接使用clazz.isAnnotationPresent等就行。这里如
	果再使用clazz.getClass()获得的是类类型的类类型对象反而会出错。
		
		5. 总之某个类或对象的类类型对象中存有关于这个类的各种信息，但是这个类类型对象的类类型对象中存放的是类类型
	对象的各种信息，这些信息是没有任何作用的。可见ReflectFrame得MyServletProcessor类。

2017.09.27
1. FileFilter接口用于过滤抽象路径名，它只有accept一个方法，该方法规定了那些路径名可以listFile(..)接收;
2. 打印所有文件(递归)
3. 获取某个包下面的所有类
4. 获取项目下的所有包名
5. 自己写一个扫描的配置文件, 然后执行这个包下面所有包含某个注解的类的某个方法
6. 求菲波那切数列
	1. http://blog.csdn.net/dadai_/article/details/50209511

2017.09.28
1. get方法访问除了url里面带参数外，能否发送数据包。只能通过将参数放在在url里面的方式;

2. 浏览器是一个HTTP客户程序。HttpClient
	1. http://itindex.net/detail/46628-apache-httpclient-4.3
	2. http://itindex.net/detail/53214-httpurlconnection-httpclient-get

3. URLHttpConnection用于应用程序和URL之间的通信, 现作如下说明

	1. 建立URLHttpConnection常用方式有两种
		1. URL url = new URL(urlPath); URLConnection connection = url.openConnection();
		2. URLConnection connection = new URLConnection(url);

	2. 通过.getInputStream()来从链接(服务器)读取数据。若该链接是一个网址则得到所有网页h5代码。
或者得到比如json数据。通过.getOutPutStream()来写入数据;

	3. URLConnection通过setReqeustMethod("Request Mthod", "POST")可以设置请求头信息，例如访问方式为POST。
但是实际上如果我们只从inputStream中读取数据实际上也是通过GET方式访问的。但是通过HttpUrlConnection.setRequestMethod("POST")
无论如何都是通过post方式访问的。也就是说URLConnection的setRequestMethod效果没有那么好；

	4. 即使我们给URLConnection对象设置了访问方式为get, 只要我们调用了getOutputStream方法，那么最终还是转换为post方式访问。
另外要想调用getOutputStream方法必须先设置setDoOutput(true)。想要读取数据不必设置setDoInput为true，因为它默认为true;

	5. 通过writer向服务器发送数据后，一定要记得关闭流，否则服务器可能接受不到数据;

	6. HttpURLConnection请求响应流程: http://blog.csdn.net/woxueliuyun/article/details/43267365;

	7. 以post方式向服务器提交数据时也可以将参数带在url地址里面，servlet也能够通过getParameter的方式获取数据。如果既在url
里带了参数，又通过writer写了数据，可以通过getParameterValues()方法获得参数值的数组;要在url中带多个参数，只需要通过&链接；
在writer写入多个参数，也通过&链接，他们两者互相不会受影响;

	8. url地址中 "&" "/"等符号的转义处理: http://xace.iteye.com/blog/481814/

	9. 服务器可以通过request.getMethod来获取访问类型

4. 关于XMLHTTPRequest
	1. https://baike.baidu.com/item/XMLHTTPRequest/6788735

5. http请求头
	1. https://baike.baidu.com/item/http%E8%AF%B7%E6%B1%82%E5%A4%B4/6623287?fr=aladdin

2017.09.29
1. ajax发送到后台的数据后台怎样接收？例如发送的是一个js对象。注意getParameter要写在getInputStream前面。

2. 何为跨域？

	1. 当两个域具有相同的协议(如http), 相同的端口(如80)，相同的host（如www.google.com)，
那么我们就可以认为它们是相同的域（协议，域名，端口都必须相同, 否则就属于跨域;

	2. 简单的Get, Post请求, 在response中添加Access-Control-Allow-Origin, 值设定为"*"表示这个资源谁都可以用;

	3. 使用xhr并设定async为false时，不要使用onreadystatechange，xmlHttp.responseText放在send()方法后面即可;
不管是post还是get，xhr.setRequestHeader必须放在open函数的后面, send的前面;

	4. ajax: http://www.w3school.com.cn/ajax/ajax_xmlhttprequest_send.asp

	5. ajax和xhr https://segmentfault.com/a/1190000004322487
	
	6. 跨域解决方案 http://blog.csdn.net/freshlover/article/details/44223467

	7. Post提交方案 http://blog.csdn.net/tycoon1988/article/details/40080691

3. jsp获取表单上传的文件 
	1. http://blog.sina.com.cn/s/blog_6cae7bcd0102wav3.html				
	2. http://www.cnblogs.com/jimmy-muyuan/p/5294654.html

2017.09.30
1. 模拟一个xss程序，盗取后台管理员的cookie并冒充管理员登录;

2. request请求头中为什么会有Cookie?--HTTP发送请求时，会把保存在该域名下的所有cookie一并发送给web服务器;

3. httpheader:
	1. http://blog.jobbole.com/48358/
	2. http://www.cnblogs.com/zhwl/archive/2012/02/28/2371691.htm

4. 锚点
	1. http://www.cnblogs.com/kaituorensheng/p/3776527.html
	2. http://www.zhangxinxu.com/wordpress/2013/08/url-anchor-html-%E9%94%9A%E7%82%B9%E5%AE%9A%E4%BD%8D%E6%9C%BA%E5%88%B6-%E5%BA%94%E7%94%A8-%E9%97%AE%E9%A2%98/

5. 使用XMLHttpRequest对象
	1. js向服务器发送数据一般步骤
	
	var xmlHttp = new XMLHttpRequest()
	// 获取请求状态，当设置async为false时不用写这一段
	xmlHttp.onreadystatechange = function() {
		if (xmlHttp.status == 200 && xmlHttp.readyState == 4) {
			alert(xmlHttp.responseText..);
		}
	}
	xmlHttp.open("请求方式(POST)", "请求地址(http:..)", 是否为异步(true));
	注意以POST方式发起请求时，也可以在请求地址后面跟上?参数=值，后台也能获取到

	当请求方式为POST，想向HTML表单那样提交数据时，可以对请求头作如下设置
	xmlHttp.setRequestHeader("Content-type", "application/x-www-form-urlencoded; charset=UTF-8");
	xml.send("数据内容(如: par1=va1&par2=va2)");
	这样在后台就可以通过request.getParameter()的方式来获取数据。注意如果不设置请求头，后台就只能通过输入流来获取前台
传输过来的数据;而且设置charset=UTF-8可以避免后台接收到的数据是乱码;

	相对应的，在使用java的HttpURLConnection类时，不用调用connection的setRequestProperty("Content-type", 
"application/x-www-form-urlencoded;charset=utf-8")[XHR的方法是setRequestHeader]。无论有没有给connection设置这个请求参数，
在servlet中都可以通过getParameter方法来获取参数，跟在url地址后面的参数也可以通过getParameter来获取。但是传给服务器中的参
数有中文时, 如果不设置这个属性，服务器收到的就是乱码。
	
	设置这个有点像提交form表单时，设置表单的enctype属性。它用于规定发送到服务器之前如何对表单数据进行编码;

	2.  注意在发送GET请求时，send()里面也可以写东西，但是后台是看不到的。控制台中也可以看到send里面的数据并没有被提交；

	3. 发送GET请求: xmlHttp.open("GET", "...?par1=v1&par2=v2", true);

	4. onreadystatechange并非一定要写在send()后面，因为是异步的。但是send必须写在open后面。添加http头必须
写在send的前面(xmlHttp.setRequestHeader), open()的后面;

	5. connection的是setRequestProperty，xhr的是setRequestHeader;

2017.10.09
1. 在ajax请求中，服务器无法设置cookie，即使在response header中有setcookie;

2017.10.10
1. 利用maven build启动Tomcat项目需要在pom.xml文件中配置，内容如下
	<build>
	    <plugins>
		    <!-- tomcat7 启动所需jar包 -->
		    <plugin>
			<groupId>org.apache.tomcat.maven</groupId>
			<artifactId>tomcat7-maven-plugin</artifactId>
			<version>2.1</version>
			<configuration>
			    <!--端口 -->
			    <port>8800</port>
			    <!--注意名称 -->
			    <path>/TextTomCat</path>
			    <uriEncoding>UTF-8</uriEncoding>
			    <!--注意此名字 启动时会用到 -->
			    <server>tomcat7</server>
			</configuration>
		    </plugin>
	    </plugins>
	 </build>
	然后在启动的时候写tomcat7:run注意这个tomcat7就是server中的名字
	配置不同的端口号可以同时启动多个tomcat服务

2. pom配置文件中maven-compiler-plugin的作用是指定jdk编译版本，可以看到我们修改这个版本之后再update project，那么
这个项目的JRE System Library就会变成相应的版本号。如果不配置，maven会使用默认版本编译;

3. pushServer

2017.10.12
1. 在线字体图片制作
http://www.qt86.com/

2. ajax-pushlet-client

2017.10.13
1. Http请求中Content-Type讲解以及在Spring MVC中的应用
http://blog.csdn.net/blueheart20/article/details/45174399

2017.10.16
1. 如何设置的倒计时，是否是push server？
2. huping分页
1. 网页聊天室
2. tomcat虚拟路径
3. 鼠标垫

1. 关于前台文件上传
	http://blog.csdn.net/oscar999/article/details/37499743/
	https://www.ibm.com/developerworks/cn/web/1101_hanbf_fileupload/
	http://www.cnblogs.com/ghfjj/p/6306386.html
	***http://www.runoob.com/jsp/jsp-file-uploading.html***

2017.10.18
1. maven单步调试进入不了代码，在source里面add项目

2017.10.20
1. 关于部署项目和配置tomcat虚拟路径:
	1. 当我们在项目中新建了一个文件夹用于保存用户上传的文件时，如果这个文件夹的路径位于我们部署在tomcat中的项目下，
那么当我们的项目代码发生了变化，且我们通过eclipse重新启动tomcat服务器时，那么这个新建的文件夹就会消失。因为我们的项目位于
eclipse的工作空间中，工作空间中的项目中没有这个新建的文件夹。而项目代码发生变化后，tomcat会重新部署这个文件，所以那
个新建的文件夹就消失了。但是如果项目代码没有发生变化，只是通过eclipse停止或打开tomcat服务器，那么该新建文件夹依然存在;

	2. 当我们直接访问一个项目时，在不加其他路径的情况下，会默认访问该项目的index.html或index.jsp页面, 也可以在web.xml
中配置welcome-file-list标签来指定默认访问界面。
		1. tomcat的默认的基准目录是webapps(基准目录由server.xml文件中的host节点下的appBase指定), 基准目录根下
	的ROOT目录被自动设置为根目录，所以访问localhost:port时，访问的是ROOT这个默认根目录下面的index.jsp页面。这个ROOT
	可以只是一个普通的文件夹而并不一定是web项目。

		2. 为什么会访问index.jsp这个界面？因为在tomcat的config目录下的web.xml文件中指定了三个默认页面为index.html/jsp/html，
	即使修改了这些参数，当有新项目发布到tomcat服务器时，这些设置还是会还原。
		
		3. 那么修改Host节点的appBase的值就会修改基准目录。但我们修改为自己的路径如E:\mywebapps，并在E:\mywebapps
	下复制粘贴一个我们在eclipse中的整个项目之后，发现仍然不能直接访问。这是因为在原本tomcat的ROOT文件夹下有一个
	index.jsp文件，而我们自己的index文件放在WebContent目录下。在我们自己的项目中加入index文件，发现可以访问。
	因为通过tomcat编译后的项目是会在目录下生成index文件的, 而自己复制的项目只相当于一个普通的文件夹而已，
	它保留着本来的目录结构。
		注意，
			1. 每次使用eclipse添加自己的项目或者clean之后，再次启动tomcat时，都会还原appBase
		的值为webapps，而且会清空host节点下面的其他<Context>节点;
			2. 仅仅只是修改了appBase节点后访问localhost:8088既不能访问tomcat的首页，也不能访问我们自己的项目。
		这是因为我们的项目名不是基准目录的默认根目录的名字ROOT，可以通过修改项目文件夹名为ROOT或者添加一个path值
		为""，docBase为我们的项目绝对路径的Context节点即可;

		4. 当制定了多个welcome-file时，按顺序加载，即写在前面的先访问;

		5. 可以修改tomcat主机名称不为localhost, 需要两个步骤
			1. 修改conf/server.xml的host节点中的name为自己想要的值，如liqiyuan, 修改后启动tomcat服务，发现
		不能用localhost，也不能用liqiyuan访问；
			2. 修改C:\Windows\System32\drivers\etc下的host文件，在其中加上本机ip比如127.0.0.1 liqiyuan，这样
		就能访问；
			3. eclipse无法修改Host name, 且当server.xml中Host节点中的name被修改为不是localhost后，无法通过
		eclipse启动或同步；
			4. 每次修改host-name后，都会在Catalina文件夹下面生成一个和host name同名的文件夹, 如liqiyuan, 且
		该文件夹为空;
		
		6. 1中已经提到过基准目录下的ROOT被自动设为根目录，那么怎么修改默认的根目录呢？在host节点下添加<context>
	节点并设置docBase为自己想要设置为根目录的项目，然后将path写为空，即path=""，这样在直接访问地址时就会进到这个目录
	下; 注意:
			1. 每一个context节点实际上就对应着一个项目;
			2. host节点下的项目的路径docBase实际上也根本没有规定一定要在tomcat的webapps这个文件夹下面，它可以
		在任何一个位置;
			3. 所以实际上appBase这个节点的意义在于，我们可以任意扔一个项目(war包)到这个路径下，tomcat会自动的去编译它
		然后供我们访问。可以看到我们直接扔进去的项目是不会早host节点下生成Context。所以webapps是给我们提供了一个便捷
		的部署项目的方法，如果项目在其他文件夹，则可以通过context来部署它;

	3. 除了修改server.xml文件的host节点下的appBase属性和在host节点下添加<Context>节点外还可以通过在Catalina文件夹中添加
配置文件的方式来访问我们的项目；

		1. 现在我们知道，我们通过localhost访问自己的项目仅仅是由server.xml中的host节点的appBase属性和host节点下面的
	Context节点的docBase以及path来决定的；

		2. 在catalina文件夹中添加xml文件来配置我们在其他位置的项目, 这个文件名必须和我们的项目文件名一致，这个xml文件
	中只有Context一个节点, 该节点只需要配置docBase一个属性;

		3. 配置server.xml和配置catalina/.xml的区别有：
			1. server.xml的host节点下可以一次配置多个项目, 而catalina中配置文件和项目一一对应;
			2. catalina下的配置不受eclipse配置的任何影响;

2017.10.23
1. 压缩代码: http://tool.lu/html/index.html
2. 图片上传前后台代码: http://www.cnblogs.com/wbyp/p/6201941.html
3. 上传文件进度条，上传文件预览
4. 关于formdata
	1. http://blog.csdn.net/liangwenmail/article/details/51921167
	2. http://www.cnblogs.com/zhuxiaojie/p/4783939.html
5. 使用ServletFileUpload时，要设置的是表单内元素的name属性而不是id属性，否则fileItem获取不到
6. FileReader读取: http://www.cnblogs.com/tandaxia/p/5125275.html

2017.10.24
1. FileReader对象
2. layerui: http://www.layui.com/doc/modules/layer.html
3. 限制前端上传文件类型: http://www.cnblogs.com/liboxncg/p/6095627.html
4. FileReader对象。在讲type=file的this值传入函数, 可以通过var file = obj.files[0]获取文件。file.name, file.type, file.size等数据;

2017.10.25
1. 多线程:
	1. http://www.cnblogs.com/zrtqsk/p/3776328.html
	2. http://www.cnblogs.com/wxd0108/p/5479442.html
	3. volatile和synchronized http://blog.csdn.net/chengzhezhijian/article/details/13621129
	4. 生产者消费者问题 http://blog.csdn.net/monkey_d_meng/article/details/6251879/
	5. list区别 http://blog.csdn.net/cmtobby/article/details/2257246

2017.10.27
1. 套接字
2. 生产者消费者java模型中, 有两种理解
	1. 可以在生产者消费者的run方法中写一个循环。这相当于是只有一个消费者线程和生产者线程，他们不断的生产和消费。比如
生产者一直生产到某个时刻，发现资源过剩，那么他会进入挂起状态，等待消费者线程唤醒他，反之消费者线程也一样; 注意，当一个对象
中有多个synchronized方法时，只要其中一个synchronized方法没有执行完毕，那么所有被synchronized修饰的方法都不能被其他线程访问;

	2. 另一种模式是run方法只执行一次动作，而在demo中开启多个消费者和生产者线程，他们都同时开始生产和消费。然后等待其他
任何一个线程对他们执行唤醒操作; 这个问题将线程同步的问题更多的关注到了生产者(消费者)线程和生产者(消费者)线程之间的冲突，
而不是他们两者之间的冲突;
	
	3. 怎么看出是不是线程安全的呢，比如我们将消费者和生产者的操作数值调整成一样的，可以看到线程安全的例子中，最后的
结果总是0，而线程非安全的例子最后的结果却是在变化的，这说明对资源的操作不是原子级别的;

3. websocket
	1. 菜鸟教程 http://www.runoob.com/html/html5-websocket.html
	2. 网页聊天室 http://www.jb51.net/article/87659.htm

2017.10.30
1. EventSource资料
	1. EventSource以及ajax轮询 http://www.jianshu.com/p/bc5a9b4a1cd1 关于轮询这个教程说的并不准确
	2. http://blog.csdn.net/junbaozi/article/details/41350537
	3. http://blog.csdn.net/bamboolsu/article/details/48653317
	4. HTML5 服务器推送事件（Server-sent Events）实战开发
		https://www.ibm.com/developerworks/cn/web/1307_chengfu_serversentevent/

2. eventsource服务端

	1. 注意服务端发送数据一定要是data: val\n\n采用冒号，这里属性名只能叫做data, 而且最后要加上两个换行;

	2. 服务端可以通过指定retry属性来修改每次请求的间隔时间;注意每个属性之间一定要用\n作为分割;

3. pushserver
	1. pushlet框架: http://cuisuqiang.iteye.com/blog/1416771
	2. http://blog.csdn.net/houpengfei111/article/details/7498481
	3. http://blog.csdn.net/p793049488/article/details/20688573
	4. https://www.cnblogs.com/linjiqin/archive/2011/12/30/2307788.html

2017.10.31
1. 何为MIME(Multipurpose Internet Mail Extensions), 多用途互联网邮件扩展类型, 比如text/html, text/event-stream,
multipart/form-data

2. 关于WebSocket
	1. 理解WebSocket http://www.cnblogs.com/tohxyblog/p/7112917.html
			 http://www.cnblogs.com/tohxyblog/p/7112947.html
			 知乎的回答: https://www.zhihu.com/question/20215561 (包含微信上部署一个小程序)
			 阮一峰: http://www.ruanyifeng.com/blog/2017/05/websocket.html

	1. WebSocket简单demo 
		1. java: http://blog.csdn.net/lipei1220/article/details/49098111
		2. http://blog.csdn.net/huitoukest/article/details/51437982

	2. WebSocket多人实时聊天 http://blog.csdn.net/qq_23994787/article/details/77543277 (结合套接字)

	3. WebSocket整合Spring MVC
		1. 即使聊天: http://blog.csdn.net/qq_33415017/article/details/53907115
		2. 点对点即时聊天 http://blog.csdn.net/qq_35992956/article/details/77992410?skintest=skin3-template-test

	4. WebSocket即时聊天 http://blog.csdn.net/ihchenchen/article/details/71440760

2017.11.01
1. java中使用ServerEndPoint来标注websocket服务端的类。这个类中主要有三个方法，分别用OnMessage, OnOpen, OnClose来标注。
被OnMessage标注的方法必选包含Session session和String message这两个参数，一个用于向客户端发送信息，一个用于接收客户端
发送过来的信息;

2. Timer的构造函数new Timer(boolean)中，如果参数为true，则它是一个守护线程，如果没有其他线程执行它将终止。使用Timer类
的schedule方法可以定时循环执行某一个方法。schedule方法的第一个参数是一个继承了TimerTask这个抽象类的一个类;

3. 关于普通轮询和长轮询
	1. 普通轮询：客户端向服务器不断发送Ajax请求，无论服务器有没有响应，客户端都发起第二次请求。客户端不断的向服务器发送
请求，显然是不合理的;

	2. 长轮询：客户端不断向服务器发送Ajax请求，服务器有数据更新时才响应，否则就hold住连接。而服务器未响应时，客户端不会
发起下一次请求，如果第二次请求返回数据之后，第三次请求又会立刻发出;

	3. 使用xhr向服务器发送请求有两种方式，一种是将xhr对象写作全局变量，一种是将其作为局部变量。
		1. 作为全局变量时客户端每次对服务器的请求都是基于同一个xhr对象，如果当前一个请求还没有得到服务器响
	应时客户端马上发起第二次请求，则前一次请求就会被停止掉。

		2. 将xhr作为局部变量写在函数中时, 每请求一次就创建一个xhr对象，每一个请求互不干扰。当前一个请求没有得到响应时，
	第二个xhr已经开始发送请求，则第一个xhr会继续等待服务器的响应。程序中可以设计两个按钮，点一次发送一个请求来替换使用
	setInterval不断发起请求的场景;

		3. 注意如果使用jquery的ajax，它使用的不是同一个xhr对象，而是多个;
	
	4. 使用长轮询, 核心都是递归:
		1. 普通xhr: http://www.cnblogs.com/zhaowinter/p/5332681.html
		2. ajax长轮询: http://www.cnblogs.com/hoojo/p/longPolling_comet_jquery_iframe_ajax.html (写的非常好)

	5. 参考资料：
		1. https://segmentfault.com/a/1190000005032908
		2. http://web.jobbole.com/85541/

4. 在servlet中向客户端发送数据时，例如在service方法中。writer.print方法一定会在整个service方法结束的时候才会执行。
比如service方法中有一个死循环，或者有一个阻塞线程，只要service方法没有执行完毕，writer.print方法就不会执行;

2017.11.03
1. 上传文件逻辑
	1. 前台通过type=file上传文件, 提交数据时头像名称和其他数据一起作为实体被提交给控制器，控制器得到的是图片的路径名(可能是
fakepath)。然后数据库存储这个实体。存储实体在service中发生，存储之后才能得到id。此时立即修改数据库中刚刚存进去的这一条数据，
将图片路径取出，只保留后缀，然后把名字改为刚刚得到的id;

	2. 另外，当数据库保存实体时，另一个控制器负责将客户端提交的图片数据保存到一个指定文件夹中, 命名为id+后缀。因为在保存
到数据库之后才存储图像数据，所以已经有id;

	3. 其实可以考虑用另一种方式来命名图片数据

2017.11.07
1. EventSource和Websocket的区别
	1. websocket发起一起xhr请求后一直保持通道连接，而eventsource会不断的发起xhr请求;

2017.11.09
1. http://edu.csdn.net/topic/web1?utm_source=blog10

2. 在webSocket的服务端，session通过getRequestParameterMap可以获得url地址中的参数, 通过getPathParameters可以获得{}里的参数。
客户端每发起一个ws的请求，实际上服务器都新生成了一个webSocket对象(通过打印this发现每一个客户端发起连接后this的值不一样证明)，
所以无法在webSocket类中通过一个普通的比如list来保存所有的session，但是可以使用一个静态的比如list来保存所有的客户端发起的
ws连接;

2017.11.10
1. comet https://www.ibm.com/developerworks/cn/web/wa-lo-comet/

2017.11.13
1. 加强对线程同步的一些理解, 来源: http://www.cnblogs.com/skywang12345/p/3479202.html

	1. 当一个线程访问某个对象的synchronized方法或synchronized代码块时:
		1. 其他线程对该对象的synchronized方法或代码块的访问将被阻塞;
		2. 其他线程对该对象的非synchronized方法或代码块的访问不会被阻塞;
		3. 其他线程对该对象的其他synchronized方法或代码块的访问将被阻塞;

	2. 对以上几点的补充说明:
		1. 同步锁只能影响同步锁内的部分，同步锁外的资源仍有可能被抢占;

		2. 同步锁只能影响其他的同样使用了同步锁的部分。例如锁住了资源s的位于不同线程内的块A和块B一定不可能
	交替执行，他们之中一定是其中一个全部执行完成后才能执行另一个。但是另个一同样使用了资源s，没有使用同步锁
	的线程中的方法却有可能在块A或B使用资源s的时候使用它;
		
		3. 根据1中的第三点，一个被synchronized修饰的方法将等待其他所有修饰对象的块或方法执行完毕后才会执行，
	一个被修饰了的块也会被所有被修饰了的方法和块阻塞。但是，锁住不同对象的块之间是不会相互阻塞的;

		4. 注意，如果被synchronized修饰的是一个静态方法，那么它和其他被修饰的块是互不影响的,
	静态的方法和实例方法之间也不会相互阻塞;

2. 在子类中想通过反射获取父类中某一个私有变量的值时，方法如下
	Class<?> superclass = this.getClass().getSuperclass();
	然后要获取哪一个父类的属性时，即调用Field的get(Object)方法时直接传this进去即可, 即可以用子类对象代替父类的对象

3. 类图各种术语解释: https://www.cnblogs.com/olvo/archive/2012/05/03/2481014.html

2017.11.14
1. 关于继承和函数重写重载等基本概念
	1. 抽象类在implement一个接口后可以不用实现任何方法。接口中的default方法也可以不需要任何类去实现它;

	2. Father {
		protected void name() {// do some work}
	}
	Son {
	public void useParentMethod() {
		// 当name函数只存在于父类中时
		// super.name和this.name都是调用的同一个函数
		
		// 当子类中有一个和父类函数签名完全一样的name函数时，super.调用父类的，this.调用子类的
		super.name();
		this.name();
	}
	
	// "重写"父类的成员时，只能用修饰范围大于等于父类的修饰词来修饰
	// 父类是protected，子类就只能使用protected或public来修饰
	/*@Override
	protected void name() {
		System.out.println("子类的name函数");
	}*/
	
	// 子类可以"重载"父类的同名函数，这个重载的函数可以任意指定修饰词
	private void name(String s) {
	
	}
	public void name(String s, String s1) {
		
	}
	
	// 不可以试图通过只改变函数返回值的类型的来重载父类的同名函数
	// 函数的返回值不属于函数的方法签名
	// 因此这样写跟在同一个类当中写了两个同名但返回值不一样的方法是一样的，是非法的
	/*public int name() {
		return 1;
	}*/

2. java集合源码分析: http://blog.csdn.net/column/details/collection.html
   线程详解: http://blog.csdn.net/ns_code/article/details/17539599

3. 关于线程
	1. 一个线程在sleep中被打断时，这个线程不会被终止，它会抛出异常然后继续执行catch块里面和后面的内容。一个线程如果没有
start()，则不管是否调用t.interrupt(), 则t.isInterrupted()的结果都为false;
	
4. 通常都将包装类如HttpServletRequestWrapper的一个子类作为内部类放在过滤器中，然后在过滤器中将request用包装类包装后传递下去;

2017.11.15
1. dns查询 http://tool.chinaz.com/dns

2. git简明教程, http://www.runoob.com/w3cnote/git-guide.html
	1. 克隆仓库
		1. 如果想克隆别人的仓库，只需要在自己的文件夹内打开git bash，然后键入git clone url就可以将该项目克隆下来，不需要
	其他任何指令.例如 git clone https://github.com/liqiyuanbetter/myNote.git 其中liqiyuanbetter是这个用户的用户名, myNote是
	他的仓库名;

		2. 也可以克隆自己的仓库, 在指定文件夹内输入git clone路径就行了，如git clone /C/Users/017548/Desktop/文档/mine，
	但是要注意, 这个路径必须要是一个git仓库，也就是git init过。而且路径的分隔符都是/

	2. 如何将自己的项目(或文件)上传到github上
		1. 首先在github上创建一个账号, 然后新建一个仓库。

		2. 配置git
			1. 右键git bash(可以在任意位置), 然后输入ssh-keygen -t rsa -C "your_email@youremail.com", 这个邮箱
		是自己注册用的邮箱账号。接下来会让我们确定生成的配置文件的路径和密码(这个密码在合并仓库或上传文件时都会用到)。
		在指定的路径下会生成git和git.pub两个文件。右键编辑git.pub文件，复制里面的key，然后在自己的账户中选择
		settings-SSH and GPG keys，选择new SSH key, 添加刚才生成的ssh, 标题可以随便取;

			2. 现在可以开始上传我们自己的项目文件，但是首先需要在项目所在文件夹中执行git init命令，让这个文件夹
		成为一个git仓库。然后执行git remote add origin git@github.com:yourName/yourRepo.git 命令，这样添加了一个远程
		连接。yourName是用户名(如果其他用户把自己邀请为贡献者，也可以写其他人的), youRepo表示要同步的git上的仓库名。

			需要注意的是：
				1. origin这个名字是可以随便取的，每增加一远程连接，在config文件中就会多一个remote 连接名。
			所以实际上每一个连接名对应的是相应的仓库的名字。而我们在push代码的时候，实际上是指定了push到仓库里
			的哪个分支上面。
		
				2. git切换连接所指向的远程仓库
					1. 使用命令 git remote set-url origin yourUrl

					2. 直接修改config文件中的url地址

				做了这种修改后会使得ssh秘钥失效, 每次都要重新输入git的账号名和密码才能push;除非删除这个远程
			连接然后再重新在add;

				3. 如果在添加远程连接的时候显示已存在，可以通过命令git remote rm origin(连接名)来删除连接;

			3. 在推送内容到服务器之前，我们还应执行git pull origin master命令来更新我们的本地仓库以和服务器的版本
		保持一致。因为我们在git上新建仓库的时候生成了一些其他的说明文件，这些文件是我们的本地仓库没有的。事实上我们每
		次提交改动之前都应该先更新我们本地的仓库来确保它已经是最新的版本

			4. 接下来依次执行以下命令, git add fileName 或git add *, git commit -m "本次提交注释"。这是git的基本
		工作流程。本地仓库由git维护的三棵树组成，第一个是我们的工作目录，它持有实际文件。第二个是暂存区(index)，它的
		作用类似缓存区域，临时保存我们所作的改动(即add后的文件)。最后是Head，它指向我们最终提交的结果, 即commit后的
		文件;

			5. 在执行commit命令之后, 我们所作的改动已经提交到了HEAD但是还没有提交到远端仓库。执行
		git push origin master来推送这些改动到服务端。注意，不论是pull命令还是push命令，都必须通过origin banch-name来
		指定是哪一个分支。我们当然也可以选择除master之外的其他分支;

	3. 版本冲突时
		1. 强制用本地文件覆盖远程仓库git push -f origin master, 加上了一个-f表示强制

		2. pull时发生版本冲突时，执行以下命令
			1. git stash(暂存本地修改), 可通过git stash list看到保存的信息;

			2. 这时再执行git pull origin ban_name就能成功执行了, 这时相当于用远端版本覆盖了本地版本。然后通过
		git stash pop stash@{0} 来还原暂存的内容这时系统会提示有冲突

			3. 打开冲突文件，手动去修改。Updated upstream 和=====之间的内容就是pull下来的内容，
		====和stashed changes之间的内容就是本地修改的内容。修改完毕后在add, commit就可以正常的提交了

	4. git撤销本地修改与回退版本
		1. 撤销没有add的本地修改用git checkout fileName, 可以直接将文件还原到最近的一次add时状态

		2. 从本地仓库中被删除的文件，不管是shift + delete还是执行命令rm fileName删除的文件都可以通过
	git checkout filename来恢复
		
		3. 撤销没有commit的本地修改用git reset --hard，这个命令会将文件还原到最近的一次commit的状态, 注意，如果只
	add了文件但是没有commit, 那么reset后那些add过的内容也会消失，也就是说reset只会保留commit的内容;那如果想找回add了但
	是丢失了的文件怎么办，可以执行: git fsck --lost-found这个命令, 然后在.git/lost-found/other这个路径下可以找到所有add
	过的文件。reset可以会滚到某一刻的commit，可以通过git reflog查看提交的日志, 日志里面是有提交时写的注释的，所有写好注释
	很有必要。如git reset --hard 90e79f8, 这会恢复到90e79f8这次commit后的样子;注意如果既没有commit也没有add, 则那些修改
	永远也找不回来，所以随时commit是好习惯;

	5. 分支 https://blog.zengrong.net/post/1746.html
		1. git checkout -b branch_name可以创建分支，git checkout branch_name可以切换分支, git branch -d branch_name
	可以删除本地分支, git push origin branch_name将分支推送到远程仓库，否则分支不可见, 它只是一个本地分支;

		2. 可以通过git branch -a 来查看所有本地的和远程分支, 白色的是本地的，绿色的是当前使用的本地分支，红色的是远程
	分支, 本地好像只能看到的自己推送的远程分支。但是仍可以在github网页上看到所有的分支，然后在本地用命令删除分支
		
		3. 删除远程分支有两种方法: git push origin :branch_name和 git push origin --delete branch_name

	6. 删除远程仓库文件
		1. git rm -r --cached fileName
		2. git commmit -m "删除fileName"
		3. 将修改提交到远程仓库 git push origin master

	7. git用户名和账号
		1. 可通过git config user.email来修改当前用户，如果这个email对应着github上的一个账号则，user.name的修改是无效
	的，贡献者的姓名始终显示为这个email对应的用户名。如果这个邮箱是一个未注册的邮箱，则贡献者会显示user.name


2017.11.16
1. 火狐早期版本下载 https://ftp.mozilla.org/pub/firefox/releases/56.0/win64/zh-CN/ 

2. 怎么把eclipse项目上传到git

3. list可以调用自己的list.sort(Comparator<T>)方法来排序，也可以使用Collections.sort(list, Comparator<T>)方法排序, Collections
默认自带一个排序器，Collections.sort(list)，注意Comparator接口中只有一个抽象方法compare(T, T)

2017.11.20
1. 关于getResource("")
	1. 注意在maven项目中, 放在src/main/resources下的文件跟直接放在src/main/java下的文件在编译后的位置都是一样的，它们都
位于项目根目录下的/target/classes这个目录，推测之所以单独有一个resources是为了方便管理。因为直接放在java下就是跟最外层的包在
同一级，如果配置文件多显得混乱;

	2. 如果写this.getClass().getClassLoader().getResource("").getFile()那么得到的是所有类编译后的类文件所在的根目录, 
在maven项目中这个路径是/target/classes/; 如果不加getClassLoader只写this.getClass().getResource().getFile()，那么得到的路径会
包括该类所在的包的路径，如/target/classes/package_name/。可以理解为这个类加载器是所有类公用的; 可以总结为放在各个包下的配置
文件不要用classLoader，而放在总的配置文件里的，或者说跟顶层包在同一级目录的配置文件需要用getClassLoader;

	3. 我们想获取文件时要以最终生成的.class文件的路径作为着手点，不能以.java的路径作为着手点

2. 静态导入import static
	1. 我们可以使用import static com...className.*，这表示将导入所有className中的静态成员，使用时就可以直接写静态成员名
而不用写类名，可以写*表示所有的静态成员，也可以只导入某一个静态成员

3. SSLSocket及其相关类
	1. http://blog.csdn.net/zdx1515888659/article/details/44593967

2017.11.21
1. 函数接口，又叫SAM, single abstract method interfaces
	1. java的函数接口是指只包含一个抽象方法的接口，在jdk1.8中，可以使用 @FunctionalInterface来给接口添加注解。注意，
函数接口可以包含多个默认方法, 也可以包含多个静态方法，因为他们都不是抽象方法。静态方法和默认方法都必须在接口中给出实现;

2. lambdab表达式基本用法
	1. 当某个函数的参数中含有"函数接口"时，传统做法是调用该函数时传入一个实现接口的匿名类，现在可以用lambda表达式替换。例如
函数foo(MyInterface i) 的参数类型是一个函数接口，那么在调用的时候可以这样写foo( (Params...) -> {// code} ) );MyInterface
中的方法有几个参数, params就有几个参数，code中返回类型也要和接口中方法一致。如果实现代码只有一行可以不加大括号，最后也不用加分
号甚至也不用写return, 如(a, b) -> a + b。用了return则一定要加大括号和分号;另外如果只有一个参数左边也不用加括号，例如: 
a -> // code

	2. 直接声明一个实现函数接口的匿名类, MyInterface i = (prarmas..) -> // code; 例如
Predicate<String> condition = str -> str.length() <= 4;

	3. lambda表达式只能引用final修饰的变量，也就是说不能在lambda内部修改定义在外部的变量，如: int a = 3; 
list.forEach(x -> {a += 1}); 这是无法编译通过的, 这个特性类似于匿名内部类;

	4. 如果想为lambda表达式的参数声明类型，那么要么为所有的参数声明，要么去掉所有参数的类型声明;

3. function包
	1. Consumer接口，这个接口有一个抽象方法 void accept(T t) 和一个默认方法 Consumer<T> andThen(Consumer<? super T> after)
。它通常用在如List接口的forEach(Consumer<T> action)中, 这个forEach方法会将list中的每一个元素传入action中的accept方法并调用
accept方法。andThen(Consumer<? super T> after) 方法返回一个Cosumer对象，这个方法会连续执行当前Consumer对象的accept方法和after
对象的accept方法;
	
	2. Predicate接口非常适合用于做过滤器, 它只有一个抽象方法boolean test(T t), 和若干默认方法and(), or(), negate(), 
isEqual(), 他们的作用和名字一样，例如可以这样使用, 
	list.stream().filter(con1.and(con2)).forEach(t -> // do some code 这类型是Consumer)，
	或者list.stream().filter(str -> str.length() <= 4)。也可以在自己的工具类中定义一个filter方法如:
	public void filter(List<String> list, Predicate condition) {
		for (String s : list) {
			if (condition.test(s)) {
				sysout(s);
			}
		}
	}
	filter(list, str -> str.length() <= 4)

	3. Function接口中有一个抽象方法apply, 这个接口常用于list.stream().map()中，用于对list进行改造;Function的定义是
Function<T, R>, apply的定义方式是R apply(T t)。这里面的T由list.stream()得到的Stream<T>决定，但是这个R是可以自己任意指定的;
	
	4. Supplier<T>接口中有一个抽象方法get, 它没有参数，返回一个T型结果;

	5. stream()中相关接口方法使用
		1. list.stream()的返回类型是一个stream流，这个stream的泛型类型是由list的泛型类型决定的, 
	例如List<String> list, list.stream()返回的是Stream<String>。对这个流所做的任何修改都不会影响到原来的list对象;

		2. list.stream().map的意思是将list中的每个元素都放到map中的Function接口中的apply中改变一次形态, 比如
	map(x -> x * 2), 那么得到的list中的每个元素都扩大了一倍。map只是对list中的元素的一种加工, 不会改变流中元素的数量;
			1. 不仅可以得到map, 我们还可以通过mapToInt方法来得到一个IntStream, IntStream中的.summaryStatistics
		方法可以得到一个IntSummaryStatitics对象，这个对象中封装了很多比如求平均值，最大最小值等方法;
			
			2. .map对这个流的改造可能是巨大的。map的返回类型是一个stream流，但是这个stream的泛型类型是
		由Function接口中的R决定的(Function中的T，也就是apply中的T都是由list.stream()的泛型决定, 根本就是list的
		泛型类型)。即.map返回的是Stream<R>, 而不再是Stream<T>。而这个R我们可以指定成任意的类型。比如我们可以这样写:

			List<String> list = Arrays.asList("Java", "Python");
			Stream<List<String>> stream 
				= list.stream().map(s -> Arrays.asList(s));// list.stream().map(Arrays::asList)
		
		在这个lambda表达式中，没有显式使用匿名类Function的对象，因此这里的Function<T, R>中的R实际上由lambda表达式
	中的返回类型来决定了，也就是R为list。这里相当于将Stream<String>转化成了Stream<List<String>>。

		3. list.stream().filter字面意思是过滤器，它的参数是一个Predicate，这个接口中有一个返回布尔型变量的函数
	accept(T t)，list中的每一个元素也都会经过它的检验，只有返回ture的才被保留在stream中。也就是说filter之后元素的
	个数可能会减少;

		4. 无论是map还是filter，返回类型都是Stream。因此都可以用forEach我们最后都可以调用forEach来遍历所有的
	stream中的值，forEach是Stream接口中的方法。list中也有一个forEach函数。这两个forEach的参数类型都是Consumer接口，
	而且这个Consumer接口的泛型都是由他们自己的泛型<T>决定的;
		
		5. Stream类型也可以通过.collect方法来转换这个流，比如.collect(Collectors.toList())方法来将这个Stream转换
	成一个list。返回的这个List中的<T>就是Stream中的这个<T>。前面说了对stream的操作不会影响启本身，而使用collect可以
	得到我们改变过后的list;

		6. Stream中的reduce方法具有将Stream中的元素两两迭代的功能。reduce方法中的参数是一个BinaryOperator<T>接口，
	reduce方法的返回类型是是Optional<T>，<T>的类型和Stream中的<T>一致。BinaryOperator接口中有一个方法apply，它的返回
	类型是<T>，形式参数有两个，类型都是<T>; 在这个T apply(T t, T u)方法中，将Stream中的元素两个为一组进行操作，如果
	只有两个元素，则直接返回结果。如果有三个元素，则它将前两个元素apply的结果与第三个元素一起传入apply中。例如有e1,
	e2, e3三个元素，则最后结果为apply(apply(e1, e2), e3)。apply的执行结果被保存在Optional的value值中，可以通过Optional
	的get()方法获取这个value的值。这个方法可以用在计算一个列表的所有元素的和等;

4. 方法引用
	1. 方法引用用于简写lambda表达式中已经存在的方法，注意方法引用只能用在lambda表达式中;

	2. 它的引用形式是: 类名::静态方法名, 或者对象::实例方法名, 注意方法名不能写括号, 也不能再写参数在里面，例如
list.forEach(System.out::println)，也不能写s ->等;

	3. 被引用的方法的参数的类型一定要和接口中方法的参数类型顺序一致

5. 贪心算法 https://baike.baidu.com/item/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/5411800

2017.11.22
1. 断言
	1. 断言用于软件的开发和测试，删除断言部分语句后，程序不应当有任何变化。不能将断言当做程序中的一个功能来使用;

	2. 断言有两种用法
		1. assert boolExpre，boolExpre是一个布尔表达式，如果表达式为false则程序抛出异常并且程序会直接退出；
		2. assert boolExpre : expression; 如果表达式为false，则程序抛出的异常信息为expression；
	
2017.11.23
1. 三元运算符需要返回值，x = a ? b : c, b和c不能是void类型

2. 序列化

3. Comparator接口和Comparable接口的区别
	1. Comparator接口中的比较方法名称是compare(T o1, T o2), 他的返回类型为int，这个方法有两个参数, List或Collections中
的sort方法里的参数是Comparator类型的;

	2. Comparable接口中的比较方法是compareTo(T o)，返回类型也是int，但是只有一个参数;

	3. Comparator常用于数组或集合的排序，例如Arrays和Collections都有一个默认的sort方法，我们也可以重载自己的sort方法。
Collection对象如list也可以调用sort方法并传入一个自己的排序器。Comparable中只有一个方法compareTo, 它主要用于单个对象之间的
比较，例如String对象就实现了这个接口，String对象的compareTo方法可以比较两个字符串的字典顺序。结合lambda表达式我们可以这样
写: list.sort((s1, s2) -> s1.compareTo(s2)); 这里list的实例化类型是String，因此s1和s2的类型也是String, list的compare方法
实际上是去调用了String对象自己的compareTo方法来为这个list排序;

4. lambda反编译
	1. http://blog.csdn.net/wwwsssaaaddd/article/details/24212693
	2. Eclipse反编译插件 http://blog.csdn.net/silentmuh/article/details/46787625

5. accumulator: 累加器

2017.11.24
1. 什么是回调函数
	1. 回调函数的不由它所属的类A的对象直接调用，而是由A的某个成员B调用。B的某个方法有一个参数的类型是A，然后利用这个方法
来使用这个回调函数。例如:
	interface I {
		void fun();
	}
	class A implements I {
		B b;
		A (B b) {this.b = b;}
		// 这个方法就是回调方法
		fun() {}
		work(Para para) {
			b.doWork(this, para);
		}
	}
	class B {
		void doWork(I i, Para para) {
			i.work();
		}
	}
	main() {
		A a = new A();
		a.work();
	}

2017.11.28
1. 上传文件进度条

2017.11.29
1. oracle游标
	1. https://www.cnblogs.com/huyong/archive/2011/05/04/2036377.html
	2. https://www.cnblogs.com/sc-xx/archive/2011/12/03/2275084.html

2. MySql子程序语法
	1. 声明变量
		1. declare声明变量只能用在begin-end之间，相当于局部变量，这些变量的声明周期到end为止，且声明变量只能在begin语句
	的开头，不能再中途声明。且声明时要指定变量的数据类型。 @变量名声明的变量是全局变量，在整个会话中都有效，不需要指定数据类
	型;
		2. 变量的赋值方法如下: set @v(或V) = 3; set @v(或V) := 3; select col into @v(或V) from t where expre; 当要同时给
	多个变量赋值时只能写一个into关键字，写法如下: select k1, k2 into @v, V，不能写select k1 into @v, k2 into V; 使用查询语句
	赋值时如果查询结果不止一条，则将最后一条结果的值赋给变量;

	2. 触发器
		1. 语法
		CREATE TRIGGER <触发器名称>  --触发器必须有名字，最多64个字符，可能后面会附有分隔符.
	它和MySQL中其他对象的命名方式基本相象.
		{ BEFORE | AFTER }  --触发器有执行的时间设置：可以设置为事件发生前或后。
		{ INSERT | UPDATE | DELETE }  --同样也能设定触发的事件：它们可以在执行insert、update或delete的过程中触发。
		ON <表名称>  --触发器是属于某一个表的:当在这个表上执行插入、 更新或删除操作的时候就导致触发器的激活。
	我们不能给同一张表的同一个事件安排两个触发器。
		FOR EACH ROW  --触发器的执行间隔：FOR EACH ROW子句通知触发器 每隔一行执行一次动作，而不是对整个表执行一次。
		<触发器SQL语句>  --触发器包含所要触发的SQL语句：这里的语句可以是任何合法的语句，包括复合语句，
	但是这里的语句受的限制和函数的一样。
		
		2. 触发器针对数据的插入，更新，删除事件。触发器都是针对某一张表的，不能给一张表的同一事件设置两个触发器;
	且不能将多个事件写在同一个触发器内;

		3. 查看某张表上的触发器用SHOW TRIGGERS LIKE 'TABLE_NAME';

	3. 函数
		1. 内置函数大全 https://www.cnblogs.com/kissdodog/p/4168721.html;

		2. 时间: DATE_FORMAT(d, f)函数中, f表达式里，%Y表示年份, 且保留4位, 即yyyy。%y保留两位, 如17。
	%m表示月份，%M会显示为月份的英文单词; %h是小时，大写表示为24小时制。%i表示为分钟数。%s表示秒数;%r则直接表示
	为带AM或PM的时间数;

		3. 自定义函数语法为 
			CREATE FUNCTION FUNCTION_NAME(PARAMS...) RETURNS(有s) TYPE(没有分号)
			BEGIN END;
	
	4. 流程控制
		1. IF .. THEN .. ELSE(没有THEN).. END IF;
		
		2. CASE .. WHEN .. THEN .. END CASE;

		3. LB: LOOP ... LEAVE LB; .. END LOOP LB;

		4. WHILE .. DO .. END WHILE;
	
	5. 在查询条件中使用exists关键字
		1. 在使用select * from t where exists (select ..)时，会将t中的每一条数据取出来，只要select结果集不为空，
	则exists就会返回true，t中则条数据就会被查询出来。比如select * from t where exists(select null)
	和select * from t的结果是一样的。所以这个exists的用法是将父表的某一条数据去和子查询中的所有数据去做比较。比如
	select * from t where exists (select * from t2 where t2.id = t.id)。注意这里不能写t2.id = id，因为在这个子查询中，
	id就是t2的id，所以查询总是有结果，因此t中所有数据都会被查询出来。这个语句和
	select * from t where id in (select id from t2)的结果是一样的。

		2. 因为exists只要查询有结果就返回true，因此子查询内容写成*，或者任何字段都可以

		3. https://www.cnblogs.com/glory-jzx/archive/2012/07/19/2599215.html

	6. 游标
		1. https://www.cnblogs.com/mqxs/p/6018766.html
		2. https://www.cnblogs.com/trying/p/3296793.html

2017.12.04
1. H5事件
	1. 文本框的onchange事件在失去焦点且文本内容发生变化时触发，onblur只要失去焦点就会触发，oninput在内容改变时触发, 
具有即时性;

2017.12.05
1. 拖动
	1. https://code.ziqiangxuetang.com/jsref/event-ondrag.html
	2. http://www.runoob.com/html/html5-draganddrop.html
	3. http://www.runoob.com/try/try.php?filename=tryjsref_ondrag
	4. http://www.runoob.com/jsref/event-ondrag.html

2. 文件上传
	1. https://www.zhihu.com/question/54553750
	2. http://www.ruanyifeng.com/blog/2012/08/file_upload.html
	3. https://www.zhuwenlong.com/blog/article/52d6769f93dcae3050000003
	4. https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest
	5. http://www.zhangxinxu.com/wordpress/2011/09/%E5%9F%BA%E4%BA%8Ehtml5%E7%9A%84%E5%8F%AF%E9%A2%84%E8%A7%88%E5%A4%9A%E5%9B%BE%E7%89%87ajax%E4%B8%8A%E4%BC%A0/

3. content-range
	1. http://blog.sina.com.cn/s/blog_ec8c9eae0102x3uu.html
	2. https://www.cnblogs.com/syfwhu/p/6116323.html

2017.12.27
1. 关于java中的进制问题
	1. 在java中，0xff和一般的数字型常量一样，例如0xff就是十进制的255，都是表示字面常量，只不过0xff是用十六进制表示的，
而255使用十进制表示的，字面常量是没有符号的。有时我们在进行位运算时，这种用十六进制表示的常量会让我们的代码更容易理解。比如
byte a = 34; a & 0xf0很明显就是要取a的高4位的值;

	2. 为什么byte型数据的数值范围是-128~127。因为java中byte型数据占8位，且最高位表示符号位。计算机中用补码保存数值，
整数的补码是其本身，显然byte型数据最大值为0111 1111，这个值是127。负数的补码是它的绝对值取反加1，因此负数的最大值应该将
符号位意外的位都写成0，即1000 0000，对后面部分000 0000取反加1得到1000 0000，注意这是一个数值，所以最高位不是符号位，这个
数值是128，所以1000 000表示的是-128;

	3. 为什么byte型数据在转换成16进制字符串时，要与上0xff。byte是8位2进制，0xff转换为8位2进制就是1111 1111。对于byte型
数据来说, 与上0xff之后还是它本身。但是java中转换16进制字符串的方法在Integer类中，这个类的toHexString方法接收一个int型参数。
在将byte b = - 10直接转换为int i = b时，因为int型数据有32位，因此剩余的24位会全部用1来补全，此时i和b在java中的十进制数值虽
然一样，但是他们的二进制表示就不一样了。b的二进制表示为1111 0110, 而i却是1111 1111 1111 1111 1111 1111 1111 0110。在调用
toHexString方法时，该方法会先将参数转化成一个int型数据，那么直接写toHexString(b)的结果就是ffff fff6。而将byte型数据与上0xff
后保留了原本的byte的8位，而高位由0补全，即b & 0xff表示为二进制为0000 0000 0000 0000 0000 0000 1111 0110, 这个数转化成16进制
为f6, 这才是正确的结果。即& 0xff保证了byte型数据转换成int型时，它的二进制数值不变;

	4. 另外转换成16进制字符串时，一个byte型数据最多需要一个两位16进制数表示。小于16时要在前面补0来保持两位一组，即15应写
为0f。很显然byte转换成的16进制字符串，凡是大于7f(即127)的都表示这个byte是负数;

	5. 在java中调用getBytes()方法时，java将字符串中的汉字等特殊符号转换后的byte数组的长度是不确定的，这跟编码方式有关;
但是一个英文字母转换成的byte数组长度一定只有1, 例如"d".getBytes() 或 "d".getBytes("UTF-8")的结果都是[100];

3. 字符串和十六进制字符串之间的相互转换
	1. 将任意字符串转换为十六进制字符串
		// 用Integer的方法
		1. String string2HexString1(String str) {
			// 这里一定要指定编码类型, 反向转换时也要指定类型
			Byte[] b = str.getBytes("UTF-8");
			StringBuilder sb = new StringBuilder();

			for (int i = 0; i < b.length; i++) {
				// 为了保证低8位的一致，这里必须要& 0xff
				int t = b[i] & 0xff;
				String s = Integer.toHexString(t);
				if (t <= 0x0f) {
					s = "0" + s;
				}
				sb.append(s);
			}

			return sb.toString();
		}

		// 自己手动转换
		2. String string2HexString2(String str) {
			// 这个数组具有这样的特点hexDights[i] == i
			char[] hexDigits = {'0', '1', '2', '3', '4', '5', ... ,'a', 'b', ... , 'f'};
			byte[] b = str.getBytes("UTF-8");
			StringBuilder sb = new StringBuilder();

			for (int i = 0; i < b.length; i++) {
				// 任何一个b[i]都可以表示为 xxxx xxxx
				// 得到高4位的值
				int high = (b[i] & 0xf0) >> 4;
				// 得到低4位的值
				int low = b[i] & 0x0f;
				
				sb.append(String.valueOf(hexDigits[high]) + String.valueOf(hexDigits[low]));
			}
			
			return sb.toString();
		}
	
	2. 将十六进制字符串转换为字符串
		String hexStringToString(String hex) {
			byte[] b = new byte[hex.length / 2];

			for (int i = 0; i < b.length; i++) {
				// 以16进制解析字符串。直接将得到的int型数据转化成byte即可
				b[i] = (byte) Integer.parseInt(hex.subString(i * 2, i * 2 + 2), 16);
			}
			return new String(b, "UTF-8");
		}
		
	3. 进制与字符串 http://www.jb51.net/article/18146.htm

4. java中的编码 https://www.cnblogs.com/lslk89/p/6898526.html

5. editplus换行
	1. Document->Word-wrap;

	2. 可以设置为定格换行还是自定义换行的列数: tool->preferences->setting&syntax->word wrap, 该界面选择边缘换行还是
自定义换行的行数;

6. >>与>>>的区别
	1. 注意任何位运算包括&，|，>>, >>>等都会先将数转换成int型数据再操作, 得到的也是int型数据。
例如byte a = -5; int b = a >> 2 或 byte b = (byte)(a >> 2);
	
	2. 对于正数>>和>>>是一样的，都是将二进制数向右移，空位用0补全

	3. 对于负数，>>操作都是补1。而>>>操作符是补0。换句话说>>>会将负数转正。但是1中已经提到过这些操作都是针对int型数据的，
例如
	byte a = -5; // 1111 1011 
	int b = a >>> 2; 

	则b的值为1073741822。这是因为1111 1011先被转化为
1111 1111 1111 1111 1111 1111 1111 1011然后右移补0得到0011 1111 1111 1111 1111 1111 1111 1110, 这个数的大小为2^30 - 2。
如果令byte c = (byte) b，则c相当于是b这个int型取后8位即1111 1110，这个值为-2