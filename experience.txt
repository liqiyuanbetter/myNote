2017.09.06
关于字节流和字符流
Object
	----InputStream，读图像之类的字节流
		----FileInputStream
		1. 它的构造函数参数是文件名(String)或文件(File), 很单纯简单
		----DataInputStream(数据输入流)
		1. 构造函数的参数是一个字节流(InputStream)
		2. 数据输入流允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型，用于读取基本数据类型，因此它的
	方法都是readInt, readLong这种read+基本数据类型的样子

	----Reader，读取数字符号等字符流
		----BufferedReader
		1. 从字节输入流中高效的读取文本, 因此其构造函数参数都是字符输入流(Reader)
		2. Reader的直接子类中, 只有BufferedReader有读取整行的readLine方法
		----InputStreamReader
		1. 字节流通向字符流的桥梁：它使用指定的 charset 读取字节并将其解码为字符
		2. 因此它的构造函数都是含字节输入流的(InputStream), 毕竟是字符流和字节流之间的桥梁
			----FileReader
			1. 它的构造函数参数是文件名(String)或文件(File), 很单纯简单
	因此可能出现这样一种非常长的声明:
		Reader reader = new BufferedReader(new InputStreamReader(new FileInputStream(new File(fileName))))

2017.09.07
1. 关于maven
	关于引用jar包的问题
			1. 在新建普通的web项目时，项目自动在build path中添加了apachet tomcat相关jar包，因此可以直接使用servlet
		但是maven项目中默认jar包只有系统jar包，此外外所有jar包都依赖于pom文件中的引入，解决方法有两个:
				1. 一个是右键项目的build path中添加Server Runtime
				2. 一个是在pom中引入依赖javax.servlet-api
			2. 另外重要的是, 在引入servlet依赖时, scrope范围一定要指定为provided，它表示在项目的编译和测试阶段该jar
		包生效。而打成war包的时候不会加入。因为比如项目运行在tomcat容器中时, tomcat会提供jar包, 再打包进去就会发生冲突；
			3. 此外, 依赖默认的范围是compile, 它表示在项目的整个测试, 编译, 打包阶段都生效

2. 关于jstl标签
	关于这里引用jstl包的问题, 如果引用的是javax.servlet.jsp.jstl而不是javax.servlet就会出错
	但是在maven仓库中显示已经将该artifact 移入了javax.servlet.jsp.jstl

3. 软件安装不安全官方说法
		you are installing software that contains unsigned content.The authenticity or validity of this software
	cannot be established.Do you want to continue with this installation?

4. Velocity 学习地址
	http://blog.csdn.net/qq_25237663/article/details/52262532
	http://ifeve.com/apache-velocity-dev/
	http://www.360doc.com/content/13/0401/13/10825198_275274565.shtml
	https://www.ibm.com/developerworks/cn/java/j-lo-velocity1/

2017.09.08
1. Velocity配置文件
	http://blog.csdn.net/glarystar/article/details/6636574
	http://blog.csdn.net/Lancelot_Lewis/article/details/51222596

2. 注意velocity的配置文件编写后要在web.xml文件中设置，设置位置在servlet的initparam里面, 比如:
	<!-- 定义自己的配置文件 -->
	<init-param>
		<param-name>org.apache.velocity.properties</param-name>
		<param-value>mvelocity.properties</param-value>
	</init-param>

3. 周末: 
	1. Ajax
	2. Spring mVC

2017.09.11
1. 买笔记本和笔
2. 学习spring不错地址:
	http://snowolf.iteye.com/blog/1628861
	http://blog.csdn.net/qq_31138523/article/details/60584333

2017.09.18
1. 将项目部署到服务器上的步骤
	1. 在eclipse中将项目打包, 方法为在maven中执行命令clean package;
	2. 项目部署到服务器上后可以不用修改服务器上的应用的数据库地址，因为数据库在服务器上，应用配置的数据
地址是127.0.0.1，运行在服务器的应用使用这个地址时就是连接的服务器上的数据库;
	3. 对应用的访问也类似，本地访问时通过localhost，服务器上结合ngix只需要将地址换为服务器ip。例如，在服务器本地访问
时也是通过localhost:port/proName，现在通过ngix映射访问--服务器ip(默认端口80)/proName时直接映射到localhost:port/proName，
这样来实现在服务器上运行在tomcat中的项目。不直接使用服务器地址:port/proName的原因是服务器只对外暴露80端口，而外部通过
请求地址的不同映射到服务器本地的不同端口上，因此访问服务器上的应用时可以不加端口号，而是通过ngix自动映射了;
	4. 将war包放入tomcat的webapp即可，tomcat会自动解释翻译项目;

2. 在tomcat的bin/catalina.bat中通过setTitle可以指定服务启动的名称，默认为tomcat。这样可以区分运行在不同版本tomcat上的应用。
3. 将tomcat的项目配置在其他文件夹的方法
4. github教程
	1. http://jingyan.baidu.com/article/f7ff0bfc7181492e27bb1360.html

2017.09.19
js变量声明提升
	http://www.cnblogs.com/silentjesse/p/4024536.html

2017.09.20
1. windows server上配置tomcat服务器，需要在防火墙--高级设置--入站规则--新建入站规则，选择端口并指定特定本地端口为8080
方可通过ip:8080访问tomcat的index
	1. 局域网中没有添加入站规则也能访问？
	2. ajax post通过？传参数
2. windows server 
	1. http://blog.163.com/smile_big/blog/static/35710579201432510300378/
	2. http://www.xitonghe.com/jiaocheng/diannao-2534.html
	3. http://www.cnblogs.com/XieSir/articles/3420154.html
	4. http://jingyan.baidu.com/article/90895e0ffb5c1764ec6b0bbb.html

3. maven打包部署
	1. http://www.cnblogs.com/tangwan/p/4662107.html
	2. http://blog.csdn.net/u010022051/article/details/50585752
	3. http://blog.csdn.net/a468903507/article/details/45392083

4. mysql
	1. http://blog.csdn.net/q98842674/article/details/12094777/
	2. http://blog.csdn.net/wengengeng/article/details/52013650
	3. http://jingyan.baidu.com/article/f3ad7d0ffc061a09c3345bf0.html
2017.09.21

<build>
		<finalName>MyDemo</finalName>
		<plugins>
			<plugin>
				<groupId>org.apache.tomcat.maven</groupId>
				<artifactId>tomcat7-maven-plugin</artifactId>
				<version>2.2</version>
				<configuration>
					<!-- <port>8088</port>
					<url>http://localhost:8080/Demo</url>
					<server>local_tomcat</server>
					<ignorePackaging>true</ignorePackaging>
					<contextReloadable>true</contextReloadable> -->
					<!-- server、username、password对应maven的setting下的配置 -->
					<!-- <server>
						<id>tomcat</id>
						<username>lqy</username>
						<password>lqy</password>
					</server> -->
					<!-- <path>/${project.build.finalName}</path> -->
					<!-- war文件路径缺省情况下指向target -->
					<!--<warFile>${basedir}/target/${project.build.finalName}.war</warFile> -->
				</configuration>
			</plugin>

			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<version>3.6.1</version>
				<configuration>
					<source>1.8</source>
					<target>1.8</target>
				</configuration>
			</plugin>

		</plugins>
	</build>
1. 安装mysql
	1. 5.7的高版本
		1. 解压mysql后在path中添加mysql的bin目录的路径，可采取添加变量%MYSQL_HOME%的形式;

		2. 在cmd命令中执行mysqld --initialize命令会在mysql根目录下生成data文件夹，保存数据库等数据。如果没有在
	path中配置bin路径，则需要在bin目录中执行mysqld命令;初始化成功后，会在data目录下生成一些文件，其中，xxx.error.log文件
	里说明了root账户的临时密码。其内容为：
		2017-09-21T01:23:31.812068Z 1 [Note] A temporary password is generated for root@localhost: Yi%#y;dtA6pp
	后面的一串字符即初始的密码;

		3. 执行安装服务命令mysqld install serverName --defaults-file="...my.ini", 其中serverName是自己指定的计算机上
	该mysql服务的名称，同时可以指定安装的配置文件。

		4. 在使用cmd登录mysql时，需要输入 mysql -u root -p, 这里不需要输入密码，回车后再输入密码即可，因为输入密码是*
	号表示的，直接在一行里面输入会暴露密码，因此命令提示enter password后再输入密码，这是输入2中初始密码即可。

		5. 进入mysql后想操纵数据库会提示操作功能不完全需要重置密码，重置密码命令为
			1. alter user 'root'@'localhost' identified by '123';
			2. set password for 'root'@'localhost'=password('123'), 此处password是一个加密的函数;
		第一次或是之后重置命令都是用的这个，因为这是在进入数据库后执行的，所以不需要输入原来的密码。

		6. 注意事项
			1. 5.7之后数据库mysql的user表中不再有password这个字段，而是修改成了authentication_string字段，该字段
		内容为加密后的密码。所以也可以通过修改user表中的user字段来修改登录名，比如将root改为lqy
			use mysql;
			update user set user="lqy" where user="root";
		这张表中的其他字段说明该用户对数据库操作的权限。

			2. 在my.ini配置文件中的[mysqld]下面加上skip-grant-tables可跳过所有密码验证，此时发现在navicat中
		使用任何账号密码登录都能成功;
			
			3. 如果忘记了密码想要重新修改，步骤如下：
				1. 停止mysql服务，将该服务对应的配置文件加上skip-grant-tables，然后重启服务进入mysql;
				2. 通过上面的方式修改密码，发现提示在skip-grant-tables无法修改，这是再键入flush privileges;
			命令，然后再次修改密码；
				3. 修改配置文件不跳过密码，然后再重启服务，通过mysql -u user -p然后输入密码登录

2. spring boot
	1. http://www.cnblogs.com/larryzeal/p/5799195.html
	2. http://www.cnblogs.com/ityouknow/p/5662753.html
	3. http://www.mldnjava.cn/book/springboot.htm

2017.09.22
1. 关于maven
	1. maven中的parent标签
		建立一个maven项目，然后再在其中新建maven module项目，则新建的子项目的pom文件中自动会生成
		<parent>
			<groupId>com.oldbutcher.maventest</groupId>
			<artifactId>Aggregator</artifactId>
			<version>0.0.1-SNAPSHOT</version>
		</parent>
		父项目中会自动生成modules标签<module>子项目名</module>
		子项目相当于集成了父项目的依赖。新建的子项目除了上面的内容和基本的pom.xml的声明外只会有一个
		<artifactId>a-persist</artifactId>
		如果新建子项目时额外指定了group-id则还会生成如<groupId>com.oldbutcher.maventest.asd</groupId>

	2. 引入parent有什么用呢？
		父项目中的所有依赖子项目会默认全部继承，也就是不需要再在子项目中添加dependency标签。但有时我们只希望引入父项
	目中的部分依赖，此时在父项目的dependency标签外再添加一层标签<dependencyManagement>。那么如果想在子项目中使用就
	需要再次使用dependency标签来引入依赖。但此时可以省略依赖中的<version>标签和<scope>标签，因为他们都由父类指定了。

	3. 另外如果父项目的pom文件中实际上可以写入多个dependencies，在dependencies中的依赖仍将全部被子项目继承。

	4. 关于import的使用
		1. import只能用在dependencyManagement下，写法如下
			<dependencyManagement>
				<dependencies>
					<dependency>
						<groupId>com.oldbutcher.maventest</groupId>
						<artifactId>Aggregator</artifactId>
						<type>pom</type>
						<scope>import</scope>
					</dependency>
				</dependencies>
			</dependencyManagement>
		2. 注意type为pom。这样该文件就引入了com.oldbutcher.maventest中的依赖，但仍需自己通过dependency标签引用。注意
	这里只能引用进父项目的dependencyManagement中的依赖，父项目的写在外面的依赖不能引入。

		3. 所以实际上子项目可以继承多个父项目，比如可以再写
			<dependency>
				<groupId>com.oldbutcher.maventest</groupId>
				<artifactId>another project artifactId</artifactId>
				<type>pom</type>
				<scope>import</scope>
			</dependency>

	5. 通过<properties>元素用户可以自定义一个或多个Maven属性，然后在POM的其他地方使用${属性名}的方式引用该属性，比如
		<properties>
			<spring.version>4.0.2.RELEASE</spring.version>
		</properties>
		然后在下面的依赖中可以这样写:
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-core</artifactId>
			<version>${spring.version}</version>
		</dependency>

2017.09.25
1. jquery中的on事件
	1. 不能使用原生js如var e = getElement..得到元素后给其添加on事件，也不能使用$("button")[0]来添加on事件;

	2. on事件中如果没有selector，那就是在该元素下面所有范围内添加了事件。例如如果是div就是整行添加。如果有selector，
该选择器必须是被添加事件元素的下面的子元素才行，否自无效。例如：
		<div id="test">
			test
			<div>sd</div>
		</div>
		$("#test").on("click", "div", function(e){} {
			console.log(this.innerHTML);
		});
	这样写之后，这个事件是添加在#test下面的div上而不是#test上，且这里的this指向的是它下面的div而不是#test, 打印sd;
	这里的this是<div>sd</div>，而如果写$(this)表示的是数组,但是该数组只有一个元素，且就是被点击的那个div。

2. jq通过选择器得到的元素跟document的到的元素本来就是两个不同的对象。例如：<button id="but">click</button>
	var but = document.getElementById("but"); 
	console.log($("#but")); // 输出结果为[button#but]
	console.log(but) // 输出结果为<button id="but">click</button>
	$("#test")里面封装了各种jquery自己定义的属性和原型

3. on用法讲解
	1. http://www.cnblogs.com/leejersey/p/3545372.html
	2. 前端特效： http://t.cn/RKj3egR

4. dom事件流，何为冒泡
	http://www.sohu.com/a/152795929_711545

5. ajax得到的数据写了dataType为json时，是否可以直接写data.属性名？可以，没写要通过JSON.parse(..)将其转换为js对象

6. trigger在每一个匹配的元素上直接触发某类事件;

2017.09.26
1. xss

2. 设置cookie为HttpOnly则无法通过js读取到该cookie信息，这样可以防止xss攻击
	1. jsession这个cookie之所以不能通过document.cookie访问是因为它是http only的，可以在谷歌中查看到它是不允许脚本访
的，且它是由服务器自动创建的；

	2. 我们可以在response中通过addCookie这个方法向浏览器中发送cookie，但是这样的cookie是可以通过脚本访问的。通过
addHeader方法可以设置cookie为httponly的，例如 
		response.addHeader("Set-Cookie", "cookie_name=cookie_value; Max-Age=2000; HttpOnly");

	3. 此外所有我们设置的cookie都能在response中看到, 例如
		Set-Cookie:coo_1=val_1
		Set-Cookie:coo_2=val_2; Max-Age=2000; HttpOnly

3. java中的反射

	1. 某个类没有默认不带参数构造函数能用newInstance吗?不能。

	2. 注解及反射：http://blog.csdn.net/zjf280441589/article/details/50444343

	3. 关于.class和getClass()方法
		1. 他们获得的都是类型类对象(注意得到的都是对象), 区别在于.class由类名直接调用, 而.getClass()由对象调用。
	而且obj.getClass == Object.class的结果为true;

		2. 注意，调用obj.getClass()获得obj的类型类对象, 但是obj.getClass().getClass()获得的是Class的类型类,
	换句话说obj.getClass().getName()打印的是obj全名, obj.getClass().getClass()打印的是java.lang.Class;

		3. 注意当某个方法的签名是 <T> .. funName(T t)时, 传入的参数必须是某个类的对象而不是某个类的类类型对象。
	传入后需要通过t.getClass()来获取该类的类对象，从而进行下一步操作如判断注解等。因此此时不可能通过类名.class传参数
	进去。因这里的t就跟一个最顶层的object类的对象一样，它并没有类类型对象的各种方法如获取注解，获取类名等，它里面只有
	Object类的几个基本方法。如果我们仍然使用t.getClass()这时得到的是Class类的类类型对象，也达不到我们想要的目的。

		4. 当方法的参数是(Class<?> clazz...)时，传入的参数只能是类类型对象, 如obj.getClass()或Obj.class, 而不能
	传入某个类的对象。此时传入的参数已经是某个类的类类型对象了，因此直接使用clazz.isAnnotationPresent等就行。这里如
	果再使用clazz.getClass()获得的是类类型的类类型对象反而会出错。
		
		5. 总之某个类或对象的类类型对象中存有关于这个类的各种信息，但是这个类类型对象的类类型对象中存放的是类类型
	对象的各种信息，这些信息是没有任何作用的。可见ReflectFrame得MyServletProcessor类。

2017.09.27
1. FileFilter接口用于过滤抽象路径名，它只有accept一个方法，该方法规定了那些路径名可以listFile(..)接收;
2. 打印所有文件(递归)
3. 获取某个包下面的所有类
4. 获取项目下的所有包名
5. 自己写一个扫描的配置文件, 然后执行这个包下面所有包含某个注解的类的某个方法
6. 求菲波那切数列
	1. http://blog.csdn.net/dadai_/article/details/50209511

2017.09.28
1. get方法访问除了url里面带参数外，能否发送数据包。只能通过将参数放在在url里面的方式;

2. 浏览器是一个HTTP客户程序。HttpClient
	1. http://itindex.net/detail/46628-apache-httpclient-4.3
	2. http://itindex.net/detail/53214-httpurlconnection-httpclient-get

3. URLHttpConnection用于应用程序和URL之间的通信, 现作如下说明

	1. 建立URLHttpConnection常用方式有两种
		1. URL url = new URL(urlPath); URLConnection connection = url.openConnection();
		2. URLConnection connection = new URLConnection(url);

	2. 通过.getInputStream()来从链接(服务器)读取数据。若该链接是一个网址则得到所有网页h5代码。
或者得到比如json数据。通过.getOutPutStream()来写入数据;

	3. URLConnection通过setReqeustMethod("Request Mthod", "POST")可以设置请求头信息，例如访问方式为POST。
但是实际上如果我们只从inputStream中读取数据实际上也是通过GET方式访问的。但是通过HttpUrlConnection.setRequestMethod("POST")
无论如何都是通过post方式访问的。也就是说URLConnection的setRequestMethod效果没有那么好；

	4. 即使我们给URLConnection对象设置了访问方式为get, 只要我们调用了getOutputStream方法，那么最终还是转换为post方式访问。
另外要想调用getOutputStream方法必须先设置setDoOutput(true)。想要读取数据不必设置setDoInput为true，因为它默认为true;

	5. 通过writer向服务器发送数据后，一定要记得关闭流，否则服务器可能接受不到数据;

	6. HttpURLConnection请求响应流程: http://blog.csdn.net/woxueliuyun/article/details/43267365;

	7. 以post方式向服务器提交数据时也可以将参数带在url地址里面，servlet也能够通过getParameter的方式获取数据。如果既在url
里带了参数，又通过writer写了数据，可以通过getParameterValues()方法获得参数值的数组;要在url中带多个参数，只需要通过&链接；
在writer写入多个参数，也通过&链接，他们两者互相不会受影响;

	8. url地址中 "&" "/"等符号的转义处理: http://xace.iteye.com/blog/481814/

	9. 服务器可以通过request.getMethod来获取访问类型

4. 关于XMLHTTPRequest
	1. https://baike.baidu.com/item/XMLHTTPRequest/6788735

5. http请求头
	1. https://baike.baidu.com/item/http%E8%AF%B7%E6%B1%82%E5%A4%B4/6623287?fr=aladdin

2017.09.29
1. ajax发送到后台的数据后台怎样接收？例如发送的是一个js对象。注意getParameter要写在getInputStream前面。

2. 何为跨域？

	1. 当两个域具有相同的协议(如http), 相同的端口(如80)，相同的host（如www.google.com)，
那么我们就可以认为它们是相同的域（协议，域名，端口都必须相同, 否则就属于跨域;

	2. 简单的Get, Post请求, 在response中添加Access-Control-Allow-Origin, 值设定为"*"表示这个资源谁都可以用;

	3. 使用xhr并设定async为false时，不要使用onreadystatechange，xmlHttp.responseText放在send()方法后面即可;
不管是post还是get，xhr.setRequestHeader必须放在open函数的后面, send的前面;

	4. ajax: http://www.w3school.com.cn/ajax/ajax_xmlhttprequest_send.asp

	5. ajax和xhr https://segmentfault.com/a/1190000004322487
	
	6. 跨域解决方案 http://blog.csdn.net/freshlover/article/details/44223467

	7. Post提交方案 http://blog.csdn.net/tycoon1988/article/details/40080691

3. jsp获取表单上传的文件 
	1. http://blog.sina.com.cn/s/blog_6cae7bcd0102wav3.html				
	2. http://www.cnblogs.com/jimmy-muyuan/p/5294654.html

2017.09.30
1. 模拟一个xss程序，盗取后台管理员的cookie并冒充管理员登录;

2. request请求头中为什么会有Cookie?--HTTP发送请求时，会把保存在该域名下的所有cookie一并发送给web服务器;

3. httpheader:
	1. http://blog.jobbole.com/48358/
	2. http://www.cnblogs.com/zhwl/archive/2012/02/28/2371691.htm

4. 锚点
	1. http://www.cnblogs.com/kaituorensheng/p/3776527.html
	2. http://www.zhangxinxu.com/wordpress/2013/08/url-anchor-html-%E9%94%9A%E7%82%B9%E5%AE%9A%E4%BD%8D%E6%9C%BA%E5%88%B6-%E5%BA%94%E7%94%A8-%E9%97%AE%E9%A2%98/

5. 使用XMLHttpRequest对象
	1. js向服务器发送数据一般步骤
	
	var xmlHttp = new XMLHttpRequest()
	// 获取请求状态，当设置async为false时不用写这一段
	xmlHttp.onreadystatechange = function() {
		if (xmlHttp.status == 200 && xmlHttp.readyState == 4) {
			alert(xmlHttp.responseText..);
		}
	}
	xmlHttp.open("请求方式(POST)", "请求地址(http:..)", 是否为异步(true));
	注意以POST方式发起请求时，也可以在请求地址后面跟上?参数=值，后台也能获取到

	当请求方式为POST，想向HTML表单那样提交数据时，可以对请求头作如下设置
	xmlHttp.setRequestHeader("Content-type", "application/x-www-form-urlencoded; charset=UTF-8");
	xml.send("数据内容(如: par1=va1&par2=va2)");
	这样在后台就可以通过request.getParameter()的方式来获取数据。注意如果不设置请求头，后台就只能通过输入流来获取前台
传输过来的数据;而且设置charset=UTF-8可以避免后台接收到的数据是乱码;

	相对应的，在使用java的HttpURLConnection类时，不用调用connection的setRequestProperty("Content-type", 
"application/x-www-form-urlencoded;charset=utf-8")。无论有没有给connection设置这个请求参数，在servlet中都可以通过
getParameter方法来获取参数，跟在url地址后面的参数也可以通过getParameter来获取。但是传给服务器中的参数有中文时如果
不设置这个属性，服务器收到的就是乱码。
	
	设置这个有点像提交form表单时，设置表单的enctype属性。它用于规定发送到服务器之前如何对表单数据进行编码;

	2.  注意在发送GET请求时，send()里面也可以写东西，但是后台是看不到的。控制台中也可以看到send里面的数据并没有被提交；

	3. 发送GET请求: xmlHttp.open("GET", "...?par1=v1&par2=v2", true);

	4. onreadystatechange并非一定要写在send()后面，因为是异步的。但是send必须写在open后面。添加http头必须
写在send的前面(xmlHttp.setRequestHeader), open()的后面;

	5. connection的是setRequestProperty，xhr的是setRequestHeader;

2017.10.09
1. 在ajax请求中，服务器无法设置cookie，即使在response header中有setcookie;

2017.10.10
1. 利用maven build启动Tomcat项目需要在pom.xml文件中配置，内容如下
	<build>
	    <plugins>
		    <!-- tomcat7 启动所需jar包 -->
		    <plugin>
			<groupId>org.apache.tomcat.maven</groupId>
			<artifactId>tomcat7-maven-plugin</artifactId>
			<version>2.1</version>
			<configuration>
			    <!--端口 -->
			    <port>8800</port>
			    <!--注意名称 -->
			    <path>/TextTomCat</path>
			    <uriEncoding>UTF-8</uriEncoding>
			    <!--注意此名字 启动时会用到 -->
			    <server>tomcat7</server>
			</configuration>
		    </plugin>
	    </plugins>
	 </build>
	然后在启动的时候写tomcat7:run注意这个tomcat7就是server中的名字
	配置不同的端口号可以同时启动多个tomcat服务

2. pom配置文件中maven-compiler-plugin的作用是指定jdk编译版本，可以看到我们修改这个版本之后再update project，那么
这个项目的JRE System Library就会变成相应的版本号。如果不配置，maven会使用默认版本编译;

3. pushServer

2017.10.12
1. 在线字体图片制作
http://www.qt86.com/

2. ajax-pushlet-client

2017.10.13
1. Http请求中Content-Type讲解以及在Spring MVC中的应用
http://blog.csdn.net/blueheart20/article/details/45174399

2017.10.16
1. 如何设置的倒计时，是否是push server？
2. huping分页
1. 网页聊天室
2. tomcat虚拟路径
3. 鼠标垫

1. 关于前台文件上传
	http://blog.csdn.net/oscar999/article/details/37499743/
	https://www.ibm.com/developerworks/cn/web/1101_hanbf_fileupload/
	http://www.cnblogs.com/ghfjj/p/6306386.html
	***http://www.runoob.com/jsp/jsp-file-uploading.html***

2017.10.18
1. maven单步调试进入不了代码，在source里面add项目

2017.10.20
1. 关于部署项目和配置tomcat虚拟路径:
	1. 当我们在项目中新建了一个文件夹用于保存用户上传的文件时，如果这个文件夹的路径位于我们部署在tomcat中的项目下，
那么当我们的项目代码发生了变化，且我们通过eclipse重新启动tomcat服务器时，那么这个新建的文件夹就会消失。因为我们的项目位于
eclipse的工作空间中，工作空间中的项目中没有这个新建的文件夹。而项目代码发生变化后，tomcat会重新部署这个文件，所以那
个新建的文件夹就消失了。但是如果项目代码没有发生变化，只是通过eclipse停止或打开tomcat服务器，那么该新建文件夹依然存在;

	2. 当我们直接访问一个项目时，在不加其他路径的情况下，会默认访问该项目的index.html或index.jsp页面, 也可以在web.xml
中配置welcome-file-list标签来指定默认访问界面。
		1. tomcat的默认的基准目录是webapps(基准目录由server.xml文件中的host节点下的appBase指定), 基准目录根下
	的ROOT目录被自动设置为根目录，所以访问localhost:port时，访问的是ROOT这个默认根目录下面的index.jsp页面。这个ROOT
	可以只是一个普通的文件夹而并不一定是web项目。

		2. 为什么会访问index.jsp这个界面？因为在tomcat的config目录下的web.xml文件中指定了三个默认页面为index.html/jsp/html，
	即使修改了这些参数，当有新项目发布到tomcat服务器时，这些设置还是会还原。
		
		3. 那么修改Host节点的appBase的值就会修改基准目录。但我们修改为自己的路径如E:\mywebapps，并在E:\mywebapps
	下复制粘贴一个我们在eclipse中的整个项目之后，发现仍然不能直接访问。这是因为在原本tomcat的ROOT文件夹下有一个
	index.jsp文件，而我们自己的index文件放在WebContent目录下。在我们自己的项目中加入index文件，发现可以访问。
	因为通过tomcat编译后的项目是会在目录下生成index文件的, 而自己复制的项目只相当于一个普通的文件夹而已，
	它保留着本来的目录结构。
		注意，
			1. 每次使用eclipse添加自己的项目或者clean之后，再次启动tomcat时，都会还原appBase
		的值为webapps，而且会清空host节点下面的其他<Context>节点;
			2. 仅仅只是修改了appBase节点后访问localhost:8088既不能访问tomcat的首页，也不能访问我们自己的项目。
		这是因为我们的项目名不是基准目录的默认根目录的名字ROOT，可以通过修改项目文件夹名为ROOT或者添加一个path值
		为""，docBase为我们的项目绝对路径的Context节点即可;

		4. 当制定了多个welcome-file时，按顺序加载，即写在前面的先访问;

		5. 可以修改tomcat主机名称不为localhost, 需要两个步骤
			1. 修改conf/server.xml的host节点中的name为自己想要的值，如liqiyuan, 修改后启动tomcat服务，发现
		不能用localhost，也不能用liqiyuan访问；
			2. 修改C:\Windows\System32\drivers\etc下的host文件，在其中加上本机ip比如127.0.0.1 liqiyuan，这样
		就能访问；
			3. eclipse无法修改Host name, 且当server.xml中Host节点中的name被修改为不是localhost后，无法通过
		eclipse启动或同步；
			4. 每次修改host-name后，都会在Catalina文件夹下面生成一个和host name同名的文件夹, 如liqiyuan, 且
		该文件夹为空;
		
		6. 1中已经提到过基准目录下的ROOT被自动设为根目录，那么怎么修改默认的根目录呢？在host节点下添加<context>
	节点并设置docBase为自己想要设置为根目录的项目，然后将path写为空，即path=""，这样在直接访问地址时就会进到这个目录
	下; 注意:
			1. 每一个context节点实际上就对应着一个项目;
			2. host节点下的项目的路径docBase实际上也根本没有规定一定要在tomcat的webapps这个文件夹下面，它可以
		在任何一个位置;
			3. 所以实际上appBase这个节点的意义在于，我们可以任意扔一个项目(war包)到这个路径下，tomcat会自动的去编译它
		然后供我们访问。可以看到我们直接扔进去的项目是不会早host节点下生成Context。所以webapps是给我们提供了一个便捷
		的部署项目的方法，如果项目在其他文件夹，则可以通过context来部署它;

	3. 除了修改server.xml文件的host节点下的appBase属性和在host节点下添加<Context>节点外还可以通过在Catalina文件夹中添加
配置文件的方式来访问我们的项目；

		1. 现在我们知道，我们通过localhost访问自己的项目仅仅是由server.xml中的host节点的appBase属性和host节点下面的
	Context节点的docBase以及path来决定的；

		2. 在catalina文件夹中添加xml文件来配置我们在其他位置的项目, 这个文件名必须和我们的项目文件名一致，这个xml文件
	中只有Context一个节点, 该节点只需要配置docBase一个属性;

		3. 配置server.xml和配置catalina/.xml的区别有：
			1. server.xml的host节点下可以一次配置多个项目, 而catalina中配置文件和项目一一对应;
			2. catalina下的配置不受eclipse配置的任何影响;

2017.10.23
1. 压缩代码: http://tool.lu/html/index.html
2. 图片上传前后台代码: http://www.cnblogs.com/wbyp/p/6201941.html
3. 上传文件进度条，上传文件预览
4. 关于formdata
	1. http://blog.csdn.net/liangwenmail/article/details/51921167
	2. http://www.cnblogs.com/zhuxiaojie/p/4783939.html
5. 使用ServletFileUpload时，要设置的是表单内元素的name属性而不是id属性，否则fileItem获取不到
6. FileReader读取: http://www.cnblogs.com/tandaxia/p/5125275.html

2017.10.24
1. FileReader对象
2. layerui: http://www.layui.com/doc/modules/layer.html
3. 限制前端上传文件类型: http://www.cnblogs.com/liboxncg/p/6095627.html
4. FileReader对象。在讲type=file的this值传入函数, 可以通过var file = obj.files[0]获取文件。file.name, file.type, file.size等数据;

2017.10.25
1. 多线程:
	1. http://www.cnblogs.com/zrtqsk/p/3776328.html
	2. http://www.cnblogs.com/wxd0108/p/5479442.html
	3. volatile和synchronized http://blog.csdn.net/chengzhezhijian/article/details/13621129
	4. 生产者消费者问题 http://blog.csdn.net/monkey_d_meng/article/details/6251879/
	5. list区别 http://blog.csdn.net/cmtobby/article/details/2257246

2017.10.27
1. 套接字
2. 生产者消费者java模型中, 有两种理解
	1. 可以在生产者消费者的run方法中写一个循环。这相当于是只有一个消费者线程和生产者线程，他们不断的生产和消费。比如
生产者一直生产到某个时刻，发现资源过剩，那么他会进入挂起状态，等待消费者线程唤醒他，反之消费者线程也一样; 注意，当一个对象
中有多个synchronized方法时，只要其中一个synchronized方法没有执行完毕，那么所有被synchronized修饰的方法都不能被其他线程访问;

	2. 另一种模式是run方法只执行一次动作，而在demo中开启多个消费者和生产者线程，他们都同时开始生产和消费。然后等待其他
任何一个线程对他们执行唤醒操作; 这个问题将线程同步的问题更多的关注到了生产者(消费者)线程和生产者(消费者)线程之间的冲突，
而不是他们两者之间的冲突;
	
	3. 怎么看出是不是线程安全的呢，比如我们将消费者和生产者的操作数值调整成一样的，可以看到线程安全的例子中，最后的
结果总是0，而线程非安全的例子最后的结果却是在变化的，这说明对资源的操作不是原子级别的;

3. websocket
	1. 菜鸟教程 http://www.runoob.com/html/html5-websocket.html
	2. 网页聊天室 http://www.jb51.net/article/87659.htm

2017.10.30
1. EventSource资料
	1. EventSource以及ajax轮询 http://www.jianshu.com/p/bc5a9b4a1cd1 关于轮询这个教程说的并不准确
	2. http://blog.csdn.net/junbaozi/article/details/41350537
	3. http://blog.csdn.net/bamboolsu/article/details/48653317
	4. HTML5 服务器推送事件（Server-sent Events）实战开发
		https://www.ibm.com/developerworks/cn/web/1307_chengfu_serversentevent/

2. eventsource服务端

	1. 注意服务端发送数据一定要是data: val\n\n采用冒号，这里属性名只能叫做data, 而且最后要加上两个换行;

	2. 服务端可以通过指定retry属性来修改每次请求的间隔时间;注意每个属性之间一定要用\n作为分割;

3. pushserver
	1. pushlet框架: http://cuisuqiang.iteye.com/blog/1416771
	2. http://blog.csdn.net/houpengfei111/article/details/7498481
	3. http://blog.csdn.net/p793049488/article/details/20688573
	4. https://www.cnblogs.com/linjiqin/archive/2011/12/30/2307788.html

2017.10.31
1. 何为MIME(Multipurpose Internet Mail Extensions), 多用途互联网邮件扩展类型, 比如text/html, text/event-stream,
multipart/form-data

2. 关于WebSocket
	1. 理解WebSocket http://www.cnblogs.com/tohxyblog/p/7112917.html
			 http://www.cnblogs.com/tohxyblog/p/7112947.html
			 知乎的回答: https://www.zhihu.com/question/20215561 (包含微信上部署一个小程序)
			 阮一峰: http://www.ruanyifeng.com/blog/2017/05/websocket.html

	1. WebSocket简单demo 
		1. java: http://blog.csdn.net/lipei1220/article/details/49098111
		2. http://blog.csdn.net/huitoukest/article/details/51437982

	2. WebSocket多人实时聊天 http://blog.csdn.net/qq_23994787/article/details/77543277 (结合套接字)

	3. WebSocket整合Spring MVC
		1. 即使聊天: http://blog.csdn.net/qq_33415017/article/details/53907115
		2. 点对点即时聊天 http://blog.csdn.net/qq_35992956/article/details/77992410?skintest=skin3-template-test

	4. WebSocket即时聊天 http://blog.csdn.net/ihchenchen/article/details/71440760

2017.11.01
1. java中使用ServerEndPoint来标注websocket服务端的类。这个类中主要有三个方法，分别用OnMessage, OnOpen, OnClose来标注。
被OnMessage标注的方法必选包含Session session和String message这两个参数，一个用于向客户端发送信息，一个用于接收客户端
发送过来的信息;

2. Timer的构造函数new Timer(boolean)中，如果参数为true，则它是一个守护线程，如果没有其他线程执行它将终止。使用Timer类
的schedule方法可以定时循环执行某一个方法。schedule方法的第一个参数是一个继承了TimerTask这个抽象类的一个类;

3. 关于普通轮询和长轮询
	1. 普通轮询：客户端向服务器不断发送Ajax请求，无论服务器有没有响应，客户端都发起第二次请求。客户端不断的向服务器发送
请求，显然是不合理的;

	2. 长轮询：客户端不断向服务器发送Ajax请求，服务器有数据更新时才响应，否则就hold住连接。而服务器未响应时，客户端不会
发起下一次请求，如果第二次请求返回数据之后，第三次请求又会立刻发出;

	3. 使用xhr向服务器发送请求有两种方式，一种是将xhr对象写作全局变量，一种是将其作为局部变量。
		1. 作为全局变量时客户端每次对服务器的请求都是基于同一个xhr对象，如果当前一个请求还没有得到服务器响
	应时客户端马上发起第二次请求，则前一次请求就会被停止掉。

		2. 将xhr作为局部变量写在函数中时, 每请求一次就创建一个xhr对象，每一个请求互不干扰。当前一个请求没有得到响应时，
	第二个xhr已经开始发送请求，则第一个xhr会继续等待服务器的响应。程序中可以设计两个按钮，点一次发送一个请求来替换使用
	setInterval不断发起请求的场景;

		3. 注意如果使用jquery的ajax，它使用的不是同一个xhr对象，而是多个;
	
	4. 使用长轮询, 核心都是递归:
		1. 普通xhr: http://www.cnblogs.com/zhaowinter/p/5332681.html
		2. ajax长轮询: http://www.cnblogs.com/hoojo/p/longPolling_comet_jquery_iframe_ajax.html (写的非常好)

	5. 参考资料：
		1. https://segmentfault.com/a/1190000005032908
		2. http://web.jobbole.com/85541/

4. 在servlet中向客户端发送数据时，例如在service方法中。writer.print方法一定会在整个service方法结束的时候才会执行。
比如service方法中有一个死循环，或者有一个阻塞线程，只要service方法没有执行完毕，writer.print方法就不会执行;

2017.11.03
1. 上传文件逻辑
	1. 前台通过type=file上传文件, 提交数据时头像名称和其他数据一起作为实体被提交给控制器，控制器得到的是图片的路径名(可能是
fakepath)。然后数据库存储这个实体。存储实体在service中发生，存储之后才能得到id。此时立即修改数据库中刚刚存进去的这一条数据，
将图片路径取出，只保留后缀，然后把名字改为刚刚得到的id;

	2. 另外，当数据库保存实体时，另一个控制器负责将客户端提交的图片数据保存到一个指定文件夹中, 命名为id+后缀。因为在保存
到数据库之后才存储图像数据，所以已经有id;

	3. 其实可以考虑用另一种方式来命名图片数据

2017.11.07
1. EventSource和Websocket的区别
	1. websocket发起一起xhr请求后一直保持通道连接，而eventsource会不断的发起xhr请求;

2017.11.09
1. http://edu.csdn.net/topic/web1?utm_source=blog10

2. 在webSocket的服务端，session通过getRequestParameterMap可以获得url地址中的参数, 通过getPathParameters可以获得{}里的参数。
客户端每发起一个ws的请求，实际上服务器都新生成了一个webSocket对象(通过打印this发现每一个客户端发起连接后this的值不一样证明)，
所以无法在webSocket类中通过一个普通的比如list来保存所有的session，但是可以使用一个静态的比如list来保存所有的客户端发起的
ws连接;

2017.11.10
1. comet https://www.ibm.com/developerworks/cn/web/wa-lo-comet/

2017.11.13
1. 加强对线程同步的一些理解, 来源: http://www.cnblogs.com/skywang12345/p/3479202.html

	1. 当一个线程访问某个对象的synchronized方法或synchronized代码块时:
		1. 其他线程对该对象的synchronized方法或代码块的访问将被阻塞;
		2. 其他线程对该对象的非synchronized方法或代码块的访问不会被阻塞;
		3. 其他线程对该对象的其他synchronized方法或代码块的访问将被阻塞;

	2. 对以上几点的补充说明:
		1. 同步锁只能影响同步锁内的部分，同步锁外的资源仍有可能被抢占;

		2. 同步锁只能影响其他的同样使用了同步锁的部分。例如锁住了资源s的位于不同线程内的块A和块B一定不可能
	交替执行，他们之中一定是其中一个全部执行完成后才能执行另一个。但是另个一同样使用了资源s，没有使用同步锁
	的线程中的方法却有可能在块A或B使用资源s的时候使用它;
		
		3. 根据1中的第三点，一个被synchronized修饰的方法将等待其他所有修饰对象的块或方法执行完毕后才会执行，
	一个被修饰了的块也会被所有被修饰了的方法和块阻塞。但是，锁住不同对象的块之间是不会相互阻塞的;

		4. 注意，如果被synchronized修饰的是一个静态方法，那么它和其他被修饰的块是互不影响的,
	静态的方法和实例方法之间也不会相互阻塞;

2. 在子类中想通过反射获取父类中某一个私有变量的值时，方法如下
	Class<?> superclass = this.getClass().getSuperclass();
	然后要获取哪一个父类的属性时，即调用Field的get(Object)方法时直接传this进去即可, 即可以用子类对象代替父类的对象

3. 类图各种术语解释: https://www.cnblogs.com/olvo/archive/2012/05/03/2481014.html

2017.11.14
1. 关于继承和函数重写重载等基本概念
	1. 抽象类在implement一个接口后可以不用实现任何方法。接口中的default方法也可以不需要任何类去实现它;

	2. Father {
		protected void name() {// do some work}
	}
	Son {
	public void useParentMethod() {
		// 当name函数只存在于父类中时
		// super.name和this.name都是调用的同一个函数
		
		// 当子类中有一个和父类函数签名完全一样的name函数时，super.调用父类的，this.调用子类的
		super.name();
		this.name();
	}
	
	// "重写"父类的成员时，只能用修饰范围大于等于父类的修饰词来修饰
	// 父类是protected，子类就只能使用protected或public来修饰
	/*@Override
	protected void name() {
		System.out.println("子类的name函数");
	}*/
	
	// 子类可以"重载"父类的同名函数，这个重载的函数可以任意指定修饰词
	private void name(String s) {
	
	}
	public void name(String s, String s1) {
		
	}
	
	// 不可以试图通过只改变函数返回值的类型的来重载父类的同名函数
	// 函数的返回值不属于函数的方法签名
	// 因此这样写跟在同一个类当中写了两个同名但返回值不一样的方法是一样的，是非法的
	/*public int name() {
		return 1;
	}*/

2. java集合源码分析: http://blog.csdn.net/column/details/collection.html
   线程详解: http://blog.csdn.net/ns_code/article/details/17539599

3. 关于线程
	1. 一个线程在sleep中被打断时，这个线程不会被终止，它会抛出异常然后继续执行catch块里面和后面的内容。一个线程如果没有
start()，则不管是否调用t.interrupt(), 则t.isInterrupted()的结果都为false;
	
4. 通常都将包装类如HttpServletRequestWrapper的一个子类作为内部类放在过滤器中，然后在过滤器中将request用包装类包装后传递下去;

2017.11.15
1. dns查询 http://tool.chinaz.com/dns

2. git简明教程, http://www.runoob.com/w3cnote/git-guide.html
	1. 克隆仓库
		1. 如果想克隆别人的仓库，只需要在自己的文件夹内打开git bash，然后键入git clone url就可以将该项目克隆下来，不需要
	其他任何指令.例如 git clone https://github.com/liqiyuanbetter/myNote.git 其中liqiyuanbetter是这个用户的用户名, myNote是
	他的仓库名;

		2. 也可以克隆自己的仓库, 在指定文件夹内输入git clone路径就行了，如git clone /C/Users/017548/Desktop/文档/mine，
	但是要注意, 这个路径必须要是一个git仓库，也就是git init过。而且路径的分隔符都是/

	2. 如何将自己的项目(或文件)上传到github上
		1. 首先在github上创建一个账号, 然后新建一个仓库。

		2. 配置git
			1. 右键git bash(可以在任意位置), 然后输入ssh-keygen -t rsa -C "your_email@youremail.com", 这个邮箱
		是自己注册用的邮箱账号。接下来会让我们确定生成的配置文件的路径和密码(这个密码在合并仓库或上传文件时都会用到)。
		在指定的路径下会生成git和git.pub两个文件。右键编辑git.pub文件，复制里面的key，然后在自己的账户中选择
		settings-SSH and GPG keys，选择new SSH key, 添加刚才生成的ssh, 标题可以随便取;

			2. 现在可以开始上传我们自己的项目文件，但是首先需要在项目所在文件夹中执行git init命令，让这个文件夹
		成为一个git仓库。然后执行git remote add origin git@github.com:yourName/yourRepo.git 命令，这样添加了一个远程
		地址yourName是用户名(如果其他用户把自己邀请为贡献者，也可以写其他人的), youRepo表示要同步的git上的仓库名。

			3. 在推送内容到服务器之前，我们还应执行git pull origin master命令来更新我们的本地仓库以和服务器的版本
		保持一致。因为我们在git上新建仓库的时候生成了一些其他的说明文件，这些文件是我们的本地仓库没有的。事实上我们每
		次提交改动之前都应该先更新我们本地的仓库来确保它已经是最新的版本

			4. 接下来依次执行以下命令, git add fileName 或git add *, git commit -m "本次提交注释"。这是git的基本
		工作流程。本地仓库由git维护的三棵树组成，第一个是我们的工作目录，它持有实际文件。第二个是暂存区(index)，它的
		作用类似缓存区域，临时保存我们所作的改动(即add后的文件)。最后是Head，它指向我们最终提交的结果, 即commit后的
		文件;

			5. 在执行commit命令之后, 我们所作的改动已经提交到了HEAD但是还没有提交到远端仓库。执行
		git push origin master来推送这些改动到服务端。注意，不论是pull命令还是push命令，都必须通过origin banch-name来
		指定是哪一个分支。我们当然也可以选择除master之外的其他分支;

	3. 版本冲突时
		1. 强制用本地文件覆盖远程仓库git push -f origin master, 加上了一个-f表示强制

		2. pull时发生版本冲突时，执行以下命令
			1. git stash(暂存本地修改), 可通过git stash list看到保存的信息;

			2. 这时再执行git pull origin ban_name就能成功执行了, 这时相当于用远端版本覆盖了本地版本。然后通过
		git stash pop stash@{0} 来还原暂存的内容这时系统会提示有冲突

			3. 打开冲突文件，手动去修改。Updated upstream 和=====之间的内容就是pull下来的内容，
		====和stashed changes之间的内容就是本地修改的内容。修改完毕后在add, commit就可以正常的提交了

	4. git撤销本地修改与回退版本
		1. 撤销没有add的本地修改用git checkout fileName, 可以直接将文件还原到最近的一次add时状态

		2. 从本地仓库中被删除的文件，不管是shift + delete还是执行命令rm fileName删除的文件都可以通过
	git checkout filename来恢复
		
		3. 撤销没有commit的本地修改用git reset --hard，这个命令会将文件还原到最近的一次commit的状态, 注意，如果只
	add了文件但是没有commit, 那么reset后那些add过的内容也会消失，也就是说reset只会保留commit的内容;那如果想找回add了但
	是丢失了的文件怎么办，可以执行: git fsck --lost-found这个命令, 然后在.git/lost-found/other这个路径下可以找到所有add
	过的文件。reset可以会滚到某一刻的commit，可以通过git reflog查看提交的日志, 日志里面是有提交时写的注释的，所有写好注释
	很有必要。如git reset --hard 90e79f8, 这会恢复到90e79f8这次commit后的样子;注意如果既没有commit也没有add, 则那些修改
	永远也找不回来，所以随时commit是好习惯;

	5. 分支 https://blog.zengrong.net/post/1746.html
		1. git checkout -b branch_name可以创建分支，git checkout branch_name可以切换分支, git branch -d branch_name
	可以删除本地分支, git push origin branch_name将分支推送到远程仓库，否则分支不可见, 它只是一个本地分支;

		2. 可以通过git branch -a 来查看所有本地的和远程分支, 白色的是本地的，绿色的是当前使用的本地分支，红色的是远程
	分支, 本地好像只能看到的自己推送的远程分支。但是仍可以在github网页上看到所有的分支，然后在本地用命令删除分支
		
		3. 删除远程分支有两种方法: git push origin :branch_name和 git push origin --delete branch_name

	6. 删除远程仓库文件
		1. git rm -r --cached fileName
		2. git commmit -m "删除fileName"
		3. 将修改提交到远程仓库 git push origin master

	7. git用户名和账号
		1. 可通过git config user.email来修改当前用户，如果这个email对应着github上的一个账号则，user.name的修改是无效
	的，贡献者的姓名始终显示为这个email对应的用户名。如果这个邮箱是一个未注册的邮箱，则贡献者会显示user.name

	8. git切换连接的远程仓库
		1. 使用命令 git remote set-url origin yourUrl

		2. 直接修改config文件中的url地址

	做了这种修改后要重新输入git的账号名和密码才能push

2017.11.16
1. 火狐早期版本下载 https://ftp.mozilla.org/pub/firefox/releases/56.0/win64/zh-CN/ 

2. 怎么把eclipse项目上传到git

3. list可以调用自己的list.sort(Comparator<T>)方法来排序，也可以使用Collections.sort(list, Comparator<T>)方法排序, Collections
默认自带一个排序器，Collections.sort(list);

2017.11.20
1. 关于getResource("")
	1. 注意在maven项目中, 放在src/main/resources下的文件跟直接放在src/main/java下的文件在编译后的位置都是一样的，它们都
位于项目根目录下的/target/classes这个目录，推测之所以单独有一个resources是为了方便管理。因为直接放在java下就是跟最外层的包在
同一级，如果配置文件多显得混乱;

	2. 如果写this.getClass().getClassLoader().getResource("").getFile()那么得到的是所有类编译后的类文件所在的根目录, 
在maven项目中这个路径是/target/classes/; 如果不加getClassLoader只写this.getClass().getResource().getFile()，那么得到的路径会
包括该类所在的包的路径，如/target/classes/package_name/。可以理解为这个类加载器是所有类公用的; 可以总结为放在各个包下的配置
文件不要用classLoader，而放在总的配置文件里的，或者说跟顶层包在同一级目录的配置文件需要用getClassLoader;

	3. 我们想获取文件时要以最终生成的.class文件的路径作为着手点，不能以.java的路径作为着手点

2. 静态导入import static
	1. 我们可以使用import static com...className.*，这表示将导入所有className中的静态成员，使用时就可以直接写静态成员名
而不用写类名，可以写*表示所有的静态成员，也可以只导入某一个静态成员

3. SSLSocket及其相关类
	1. http://blog.csdn.net/zdx1515888659/article/details/44593967

2017.11.21
1. 函数接口，又叫SAM, single abstract method interfaces
	1. java的函数接口是指只包含一个抽象方法的接口，在jdk1.8中，可以使用 @FunctionalInterface来给接口添加注解。注意，函数接口
可以包含多个默认方法, 也可以包含多个静态方法，因为他们都不是抽象方法。静态方法和默认方法都必须在接口中给出实现;

2. lambdab表达式基本用法
	1. 当某个函数的参数中含有"函数接口"时，传统做法是调用该函数时传入一个实现接口的匿名类，现在可以用lambda表达式替换。例如
函数foo(MyInterface i) 的参数类型是一个函数接口，那么在调用的时候可以这样写foo( (Params...) -> {// code} ) );MyInterface
中的方法有几个参数, params就有几个参数，code中返回类型也要和接口中方法一致。如果实现代码只有一行可以不加大括号，最后也不用加分
号甚至也不用写return, 如(a, b) -> a + b。用了return则一定要加大括号和分号;另外如果只有一个参数左边也不用加括号，例如: 
a -> // code

	2. 直接声明一个实现函数接口的匿名类, MyInterface i = (prarmas..) -> // code; 例如
Predicate<String> condition = str -> str.length() <= 4;

3. function包
	1. Consumer接口，这个接口有一个抽象方法 void accept(T t) 和一个默认方法 Consumer<T> andThen(Consumer<? super T> after)
。它通常用在如List接口的forEach(Consumer<T> action)中, 这个forEach方法会将list中的每一个元素传入action中的accept方法并调用
accept方法。andThen(Consumer<? super T> after) 方法返回一个Cosumer对象，这个方法会连续执行当前Consumer对象的accept方法和after
对象的accept方法;
	
	2. Predicate接口非常适合用于做过滤器, 它只有一个抽象方法test(T t), 和若干默认方法and(), or(), negate(), isEqual(),
他们的作用和名字一样，例如可以这样使用。list.stream().filter(con1.and(con2)).forEach(t -> // do some code 这类型是Consumer)，
或者list.stream().filter(n -> str.length() <= 4)。也可以自己写一个filter方法如:
	public void filter(List<String> list, Predicate condition) {
		for (String s : list) {
			if (condition.test(s)) {
				sysout(s);
			}
		}
	}
	filter(list, str -> str.length() <= 4)

4. 方法引用
	1. 究竟是哪一个remote呢